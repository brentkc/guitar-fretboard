<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Guitar Scale Explorer</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&family=JetBrains+Mono:wght@400;600&display=swap');

  :root {
    --bg-primary: #0a0a0f;
    --bg-secondary: #12121a;
    --bg-tertiary: #1a1a28;
    --bg-card: #16162266;
    --border: #2a2a3a;
    --text-primary: #e8e8f0;
    --text-secondary: #8888aa;
    --text-muted: #555570;
    --accent: #6c5ce7;
    --accent-glow: #6c5ce740;
    --common-glow: #ffd700;
    --chord-accent: #e84393;
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
    background: var(--bg-primary);
    color: var(--text-primary);
    min-height: 100vh;
    overflow-x: hidden;
  }

  body::before {
    content: '';
    position: fixed;
    top: -20%;
    left: -10%;
    width: 50%;
    height: 50%;
    background: radial-gradient(circle, #6c5ce708 0%, transparent 70%);
    pointer-events: none;
    z-index: 0;
  }
  body::after {
    content: '';
    position: fixed;
    bottom: -20%;
    right: -10%;
    width: 60%;
    height: 60%;
    background: radial-gradient(circle, #e8439308 0%, transparent 70%);
    pointer-events: none;
    z-index: 0;
  }

  .app { position: relative; z-index: 1; max-width: 1600px; margin: 0 auto; padding: 20px 30px; }

  .header { text-align: center; margin-bottom: 24px; padding: 20px 0; }
  .header h1 {
    font-size: 2.2em;
    font-weight: 800;
    background: linear-gradient(135deg, #6c5ce7, #a855f7, #e84393);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    letter-spacing: -0.5px;
  }
  .header p { color: var(--text-secondary); font-size: 0.95em; margin-top: 6px; font-weight: 300; }

  .controls {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 16px;
    margin-bottom: 20px;
  }
  @media (max-width: 900px) { .controls { grid-template-columns: 1fr; } }

  .panel {
    background: var(--bg-card);
    border: 1px solid var(--border);
    border-radius: 14px;
    padding: 18px;
    backdrop-filter: blur(10px);
  }
  .panel-title {
    font-size: 0.75em;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 1.5px;
    color: var(--text-muted);
    margin-bottom: 12px;
  }
  .panel-title .count { font-weight: 700; }

  .note-grid { display: flex; flex-wrap: wrap; gap: 6px; }
  .note-btn {
    width: 52px;
    height: 40px;
    border: 1px solid var(--border);
    border-radius: 8px;
    background: var(--bg-tertiary);
    color: var(--text-primary);
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.85em;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s;
    display: flex;
    align-items: center;
    justify-content: center;
  }
  .note-btn:hover {
    background: var(--accent);
    border-color: var(--accent);
    transform: translateY(-1px);
    box-shadow: 0 4px 12px var(--accent-glow);
  }
  .note-btn.active {
    background: var(--accent);
    border-color: var(--accent);
    box-shadow: 0 2px 15px var(--accent-glow);
  }

  .toolbar {
    display: flex;
    gap: 16px;
    margin-bottom: 16px;
    flex-wrap: wrap;
    align-items: center;
  }
  .toolbar-group { display: flex; align-items: center; gap: 8px; }
  .toolbar-label {
    font-size: 0.72em;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 1.2px;
    color: var(--text-muted);
  }
  .toggle-btn {
    padding: 7px 14px;
    border: 1px solid var(--border);
    border-radius: 8px;
    background: var(--bg-tertiary);
    color: var(--text-secondary);
    font-family: 'Inter', sans-serif;
    font-size: 0.8em;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s;
  }
  .toggle-btn:hover { border-color: var(--accent); color: var(--text-primary); }
  .toggle-btn.active {
    background: var(--accent);
    border-color: var(--accent);
    color: #fff;
    box-shadow: 0 2px 10px var(--accent-glow);
  }

  .scale-categories, .chord-categories { display: flex; flex-direction: column; gap: 14px; }
  .scale-category-title, .chord-category-title {
    font-size: 0.7em;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 1.5px;
    color: var(--text-muted);
    margin-bottom: 6px;
    padding-bottom: 4px;
    border-bottom: 1px solid var(--border);
  }
  .scale-grid, .chord-grid { display: flex; flex-wrap: wrap; gap: 5px; }
  .scale-btn, .chord-btn {
    padding: 5px 12px;
    border: 1px solid var(--border);
    border-radius: 6px;
    background: var(--bg-tertiary);
    color: var(--text-secondary);
    font-family: 'Inter', sans-serif;
    font-size: 0.78em;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s;
    position: relative;
  }
  .scale-btn:hover, .chord-btn:hover { border-color: #666; color: var(--text-primary); }
  .scale-btn.active, .chord-btn.active {
    color: #fff;
    font-weight: 600;
    transform: translateY(-1px);
  }
  .scale-btn .color-dot, .chord-btn .color-dot {
    display: none;
    width: 7px;
    height: 7px;
    border-radius: 50%;
    margin-right: 4px;
    vertical-align: middle;
  }
  .scale-btn.active .color-dot, .chord-btn.active .color-dot { display: inline-block; }
  .chord-btn .color-dot { border-radius: 2px; }

  .fretboard-wrap {
    background: var(--bg-card);
    border: 1px solid var(--border);
    border-radius: 16px;
    padding: 24px 20px;
    margin-bottom: 16px;
    backdrop-filter: blur(10px);
    overflow-x: auto;
  }
  .fretboard-container { position: relative; margin: 0 auto; }
  canvas#fretboard { display: block; margin: 0 auto; border-radius: 8px; }

  .legend {
    background: var(--bg-card);
    border: 1px solid var(--border);
    border-radius: 14px;
    padding: 16px 18px;
    backdrop-filter: blur(10px);
  }
  .legend-title {
    font-size: 0.72em;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 1.5px;
    color: var(--text-muted);
    margin-bottom: 10px;
  }
  .legend-items { display: flex; flex-wrap: wrap; gap: 14px; align-items: center; }
  .legend-item {
    display: flex;
    align-items: center;
    gap: 7px;
    font-size: 0.82em;
    color: var(--text-secondary);
  }
  .legend-swatch {
    width: 16px;
    height: 16px;
    border-radius: 50%;
    border: 2px solid transparent;
    flex-shrink: 0;
  }
  .legend-swatch.common {
    background: var(--common-glow) !important;
    border: 2px solid #fff;
    box-shadow: 0 0 8px var(--common-glow);
  }
  .legend-swatch.root {
    width: 18px;
    height: 18px;
    border-radius: 3px;
    transform: rotate(45deg);
  }
  .legend-swatch.chord-ring {
    background: transparent !important;
    border: 3px solid;
    border-radius: 3px;
  }
  .info-bar {
    display: flex;
    flex-wrap: wrap;
    gap: 20px;
    margin-top: 12px;
    padding-top: 10px;
    border-top: 1px solid var(--border);
  }
  .info-item { font-size: 0.78em; color: var(--text-muted); }
  .info-item strong { color: var(--text-secondary); font-weight: 600; }

  .display-options { display: flex; gap: 6px; }

  ::-webkit-scrollbar { height: 6px; }
  ::-webkit-scrollbar-track { background: transparent; }
  ::-webkit-scrollbar-thumb { background: var(--border); border-radius: 3px; }

  .clear-btn {
    padding: 7px 16px;
    border: 1px solid #e74c3c44;
    border-radius: 8px;
    background: #e74c3c18;
    color: #e74c3c;
    font-family: 'Inter', sans-serif;
    font-size: 0.8em;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s;
  }
  .clear-btn:hover { background: #e74c3c33; border-color: #e74c3c88; }

  .tuning-select {
    padding: 7px 12px;
    border: 1px solid var(--border);
    border-radius: 8px;
    background: var(--bg-tertiary);
    color: var(--text-primary);
    font-family: 'Inter', sans-serif;
    font-size: 0.8em;
    cursor: pointer;
    outline: none;
  }
  .tuning-select:focus { border-color: var(--accent); }
  .tuning-select option { background: var(--bg-secondary); }

  /* Tabs for scale/chord panels */
  .tab-bar {
    display: flex;
    gap: 0;
    margin-bottom: 14px;
    border-bottom: 2px solid var(--border);
  }
  .tab-btn {
    padding: 8px 20px;
    border: none;
    background: none;
    color: var(--text-muted);
    font-family: 'Inter', sans-serif;
    font-size: 0.82em;
    font-weight: 600;
    cursor: pointer;
    position: relative;
    transition: color 0.2s;
  }
  .tab-btn:hover { color: var(--text-secondary); }
  .tab-btn.active {
    color: var(--text-primary);
  }
  .tab-btn.active::after {
    content: '';
    position: absolute;
    bottom: -2px;
    left: 0;
    right: 0;
    height: 2px;
    background: var(--accent);
    border-radius: 1px;
  }
  .tab-btn.chord-tab.active::after {
    background: var(--chord-accent);
  }
  .tab-content { display: none; }
  .tab-content.active { display: block; }

  .chord-formula {
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.7em;
    color: var(--text-muted);
    margin-left: 4px;
  }

  .group-tag {
    display: inline-block;
    border-radius: 5px;
    padding: 3px 10px;
    font-size: 0.78em;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.15s;
    border: 1.5px solid var(--border);
    background: var(--bg-tertiary);
    color: var(--text-secondary);
    user-select: none;
  }
  .group-tag:hover { transform: translateY(-1px); filter: brightness(1.2); }
  .group-tag.active {
    font-weight: 700;
    transform: translateY(-1px);
    box-shadow: 0 2px 10px var(--accent-glow);
  }

  /* ===== SIMPLE / ADVANCED MODE ===== */
  .mode-pill {
    padding: 5px 16px;
    border: 1.5px solid var(--border);
    border-radius: 20px;
    background: var(--bg-tertiary);
    color: var(--text-secondary);
    font-family: 'Inter', sans-serif;
    font-size: 0.76em;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.25s;
    letter-spacing: 0.2px;
    white-space: nowrap;
  }
  .mode-pill:hover { border-color: var(--accent); color: var(--text-primary); }
  .mode-pill.adv { background: linear-gradient(135deg,#6c5ce718,#a855f718); border-color: #a855f7; color: #c084fc; }
  .simple-mode .advanced-only { display: none !important; }

  /* ===== CHORD DIAGRAMS ===== */
  .chord-diagrams-wrap {
    display: flex;
    gap: 12px;
    flex-wrap: wrap;
    margin-bottom: 16px;
  }
  .chord-diagram-card {
    background: var(--bg-card);
    border: 1px solid var(--border);
    border-radius: 12px;
    padding: 10px 12px;
    backdrop-filter: blur(10px);
    text-align: center;
  }
  .cdg-title {
    font-size: 0.72em;
    font-weight: 700;
    margin-bottom: 6px;
  }
  .cdg-nav {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 6px;
    margin-top: 6px;
  }
  .cdg-nav button {
    padding: 2px 7px;
    border: 1px solid var(--border);
    border-radius: 4px;
    background: var(--bg-tertiary);
    color: var(--text-secondary);
    font-size: 0.68em;
    cursor: pointer;
  }
  .cdg-nav button:hover { border-color: var(--accent); color: var(--text-primary); }
  .cdg-nav span { font-size: 0.68em; color: var(--text-muted); font-family: 'JetBrains Mono', monospace; }

  /* ===== TAB PLAYER ===== */
  .tab-textarea {
    width: 100%;
    min-height: 130px;
    background: var(--bg-secondary);
    border: 1px solid var(--border);
    border-radius: 8px;
    color: var(--text-primary);
    font-family: 'JetBrains Mono', monospace;
    font-size: 0.8em;
    padding: 10px 12px;
    resize: vertical;
    outline: none;
    line-height: 1.6;
    margin-bottom: 10px;
  }
  .tab-textarea:focus { border-color: var(--accent); }
  .tab-textarea::placeholder { color: var(--text-muted); }
  .tab-ctrl-row { display: flex; align-items: center; gap: 8px; flex-wrap: wrap; margin-bottom: 10px; }
  .tab-ctrl-btn {
    padding: 6px 14px;
    border: 1px solid var(--border);
    border-radius: 8px;
    background: var(--bg-tertiary);
    color: var(--text-secondary);
    font-family: 'Inter', sans-serif;
    font-size: 0.8em;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.2s;
  }
  .tab-ctrl-btn:hover { border-color: var(--accent); color: var(--text-primary); }
  .tab-ctrl-btn.tcb-load { border-color: var(--accent); color: var(--accent); }
  .tab-ctrl-btn.tcb-load:hover { background: var(--accent); color: #fff; }
  .tab-ctrl-btn.tcb-play { background:#00b89418; border-color:#00b89466; color:#00b894; }
  .tab-ctrl-btn.tcb-play:hover, .tab-ctrl-btn.tcb-play.active { background:#00b894; color:#fff; border-color:#00b894; }
  .tab-ctrl-btn.tcb-stop { background:#e74c3c14; border-color:#e74c3c44; color:#e74c3c; }
  .tab-ctrl-btn.tcb-stop:hover { background:#e74c3c28; border-color:#e74c3c88; }
  .tab-ctrl-btn.active { background: var(--accent); border-color: var(--accent); color: #fff; }
  .bpm-inp {
    width: 60px; padding: 6px 8px;
    border: 1px solid var(--border); border-radius: 8px;
    background: var(--bg-tertiary); color: var(--text-primary);
    font-family: 'JetBrains Mono', monospace; font-size: 0.82em;
    font-weight: 600; text-align: center; outline: none;
  }
  .bpm-inp:focus { border-color: var(--accent); }
  .tab-divider { height: 1px; background: var(--border); margin: 10px 0; }
  .tab-prog-bar { height: 5px; background: var(--bg-tertiary); border-radius: 3px; border: 1px solid var(--border); overflow: hidden; margin-bottom: 6px; }
  .tab-prog-fill { height: 100%; background: linear-gradient(90deg,#00b894,#00cec9); border-radius: 3px; width: 0%; transition: width 0.08s; }
  .tab-status-row { display: flex; justify-content: space-between; align-items: center; font-size: 0.78em; }
  .tab-beat-label { color: var(--text-secondary); font-family: 'JetBrains Mono', monospace; }
  .tab-note-status { color: var(--text-muted); font-family: 'JetBrains Mono', monospace; }
  .tab-btn.tab-player-tab.active::after { background: #00b894 !important; }
</style>
</head>
<body>
<div class="app">
  <div class="header" style="position:relative;">
    <h1>Guitar Scale Explorer</h1>
    <p>Visualize scales, chords, and how they overlap on the fretboard <span style="font-size:0.7em;color:var(--text-muted);">v2.2</span></p>
    <div style="position:absolute;top:50%;right:0;transform:translateY(-50%);display:flex;align-items:center;gap:10px;">
      <a href="tutorials.html" style="font-size:0.78em;font-weight:600;color:var(--text-secondary);text-decoration:none;padding:5px 12px;border:1px solid var(--border);border-radius:20px;background:var(--bg-tertiary);transition:all 0.2s;" onmouseover="this.style.borderColor='var(--accent)';this.style.color='var(--text-primary)'" onmouseout="this.style.borderColor='var(--border)';this.style.color='var(--text-secondary)'">ðŸ“– Tutorials</a>
      <button class="mode-pill" id="modePill" onclick="toggleMode()" title="Toggle Simple / Advanced mode">Simple &#8644; Advanced</button>
    </div>
  </div>

  <div class="toolbar">
    <div class="toolbar-group">
      <span class="toolbar-label">View</span>
      <button class="toggle-btn" id="flipH" onclick="toggleFlipH()" title="Flip for left-handed">&#8596; Flip H</button>
      <button class="toggle-btn active" id="flipV" onclick="toggleFlipV()" title="Flip string order">&#8597; Flip V</button>
      <button class="toggle-btn advanced-only" id="rotateBtn" onclick="toggleVertical()" title="Rotate fretboard vertical with falling notes">&#10227; Vertical</button>
    </div>
    <div class="toolbar-group">
      <span class="toolbar-label">Labels</span>
      <div class="display-options">
        <button class="toggle-btn active" id="labelNotes" onclick="setLabelMode('notes')">Notes</button>
        <button class="toggle-btn advanced-only" id="labelIntervals" onclick="setLabelMode('intervals')">Intervals</button>
        <button class="toggle-btn advanced-only" id="labelDegrees" onclick="setLabelMode('degrees')">Degrees</button>
      </div>
    </div>
    <div class="toolbar-group">
      <span class="toolbar-label">Tuning</span>
      <select class="tuning-select" id="tuningSelect" onchange="changeTuning()">
        <option value="standard">Standard (EADGBE)</option>
        <option value="dropD">Drop D (DADGBE)</option>
        <option value="halfDown">Half Step Down (Eb)</option>
        <option value="fullDown">Full Step Down (D)</option>
        <option value="openG" data-advanced="true">Open G (DGDGBD)</option>
        <option value="openD" data-advanced="true">Open D (DADF#AD)</option>
        <option value="dadgad" data-advanced="true">DADGAD</option>
        <option value="openE" data-advanced="true">Open E (EBEG#BE)</option>
        <option value="openA" data-advanced="true">Open A (EAEAC#E)</option>
      </select>
    </div>
    <div class="toolbar-group" id="fretGroup">
      <span class="toolbar-label">Frets</span>
      <button class="toggle-btn fret-btn" onclick="setFrets(12)">12</button>
      <button class="toggle-btn fret-btn active" onclick="setFrets(15)">15</button>
      <button class="toggle-btn fret-btn" onclick="setFrets(19)">19</button>
      <button class="toggle-btn fret-btn" onclick="setFrets(22)">22</button>
      <button class="toggle-btn fret-btn" onclick="setFrets(24)">24</button>
    </div>
    <div class="toolbar-group">
      <span class="toolbar-label">Cycle Root</span>
      <button class="toggle-btn" id="cycleBtn" onclick="toggleCycle()">&#9654; Play</button>
      <select class="tuning-select advanced-only" id="cycleSpeed" onchange="updateCycleSpeed()" title="Animation speed">
        <option value="1500">Slow</option>
        <option value="800" selected>Medium</option>
        <option value="400">Fast</option>
      </select>
      <select class="tuning-select advanced-only" id="cycleMode" title="Cycle pattern">
        <option value="chromatic">Chromatic</option>
        <option value="fourths">Circle of 4ths</option>
        <option value="fifths">Circle of 5ths</option>
        <option value="scaleNotes">Scale Notes</option>
      </select>
    </div>
    <div class="toolbar-group" style="margin-left:auto;">
      <button class="clear-btn" onclick="clearAll()">Clear All</button>
    </div>
  </div>

  <div class="controls">
    <div class="panel">
      <div class="panel-title">Root Note</div>
      <div class="note-grid" id="rootNotes"></div>
    </div>
    <div class="panel">
      <div class="panel-title">Quick Info</div>
      <div id="quickInfo" style="font-size:0.82em; color:var(--text-secondary); line-height:1.6;">
        <div style="color:var(--text-muted); font-size:0.9em;">Select a root, then pick scales and/or chords below.</div>
        <div style="margin-top:8px;">
          <span style="display:inline-block; width:12px; height:12px; background:#4FC3F7; border-radius:50%; vertical-align:middle;"></span> Scale notes = circles<br>
          <span style="display:inline-block; width:12px; height:12px; border:2.5px solid #ff4757; border-radius:3px; vertical-align:middle;"></span> <span style="color:#ff4757;">Root</span> &nbsp;
          <span style="display:inline-block; width:12px; height:12px; border:2.5px solid #fdcb6e; border-radius:3px; vertical-align:middle;"></span> <span style="color:#fdcb6e;">3rd</span> &nbsp;
          <span style="display:inline-block; width:12px; height:12px; border:2.5px solid #00cec9; border-radius:3px; vertical-align:middle;"></span> <span style="color:#00cec9;">5th</span> &nbsp;
          <span style="display:inline-block; width:12px; height:12px; border:2.5px solid #a29bfe; border-radius:3px; vertical-align:middle;"></span> <span style="color:#a29bfe;">7th</span><br>
          <span style="display:inline-block; width:14px; height:14px; background:var(--accent); border-radius:3px; transform:rotate(45deg); vertical-align:middle; margin-right:2px;"></span> Root note = diamond<br>
          <span style="display:inline-block; width:12px; height:12px; background:#ffd700; border:2px solid #fff; border-radius:50%; vertical-align:middle;"></span> Common = gold
        </div>
      </div>
    </div>
    <div class="panel" style="grid-column: 1 / -1;">
      <div class="tab-bar">
        <button class="tab-btn scales-tab active" onclick="switchTab('scales')">Scales <span id="scaleCount" class="count" style="color:var(--accent);"></span></button>
        <button class="tab-btn chord-tab" onclick="switchTab('chords')">Chords <span id="chordCount" class="count" style="color:var(--chord-accent);"></span></button>
        <button class="tab-btn tab-player-tab" onclick="switchTab('tab')">Tab Player</button>
      </div>
      <div class="tab-content active" id="tab-scales">
        <div class="scale-categories" id="scaleList"></div>
      </div>
      <div class="tab-content" id="tab-chords">
        <div class="chord-categories" id="chordList"></div>
      </div>
      <div class="tab-content" id="tab-tab">
        <textarea class="tab-textarea" id="tabTextarea" placeholder="Paste your ASCII guitar tab here, e.g.&#10;e|--0-2-3-|-5-3-2-|&#10;B|--1-3-5-|-6-5-3-|&#10;G|--0-2-4-|-5-4-2-|&#10;D|--2-3-5-|-7-5-3-|&#10;A|--3-5-7-|-x-x-x-|&#10;E|--x-x-x-|-x-x-x-|"></textarea>
        <div class="tab-ctrl-row">
          <button class="tab-ctrl-btn tcb-load" onclick="loadTab()">&#9654; Load Tab</button>
          <span style="color:var(--text-muted);font-size:0.82em;">BPM:</span>
          <input class="bpm-inp" id="tabBpm" type="number" value="120" min="40" max="300">
          <span style="color:var(--text-muted);font-size:0.82em;">&#9833;</span>
          <span id="tabBeatCount" style="font-size:0.78em;color:var(--text-muted);font-family:'JetBrains Mono',monospace;"></span>
        </div>
        <div class="tab-divider"></div>
        <div class="tab-ctrl-row">
          <button class="tab-ctrl-btn" onclick="tabSeekStart()" title="Go to start">&#9646;&#9664;</button>
          <button class="tab-ctrl-btn tcb-play" id="tabPlayBtn" onclick="tabPlayPause()">&#9654; Play</button>
          <button class="tab-ctrl-btn tcb-stop" onclick="tabStop()">&#9632; Stop</button>
          <button class="tab-ctrl-btn" id="tabLoopBtn" onclick="tabToggleLoop()" title="Loop">&#8635; Loop</button>
        </div>
        <div class="tab-prog-bar"><div class="tab-prog-fill" id="tabProgFill"></div></div>
        <div class="tab-status-row">
          <span class="tab-beat-label" id="tabBeatDisplay">Beat &#8212; / &#8212;</span>
          <span class="tab-note-status" id="tabNoteStatus">Load a tab to begin</span>
        </div>
      </div>
    </div>
  </div>

  <div id="chordDiagrams"></div>

  <div class="fretboard-wrap">
    <div class="fretboard-container">
      <canvas id="fretboard"></canvas>
    </div>
  </div>

  <div class="legend" id="legendPanel">
    <div class="legend-title">Active Selections</div>
    <div class="legend-items" id="legendItems">
      <span style="color:var(--text-muted); font-size:0.85em;">Select a root note and at least one scale or chord to begin</span>
    </div>
    <div class="info-bar" id="infoBar"></div>
  </div>
</div>

<script>
// ===== NOTE & MUSIC THEORY DATA =====
const NOTES = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];
const INTERVAL_NAMES = ['R','m2','M2','m3','M3','P4','TT','P5','m6','M6','m7','M7'];
const DEGREE_NAMES = ['1','b2','2','b3','3','4','b5','5','b6','6','b7','7'];

// Tunings (MIDI note numbers, low to high string)
const TUNINGS = {
  standard:  [40,45,50,55,59,64],
  dropD:     [38,45,50,55,59,64],
  openG:     [38,43,50,55,59,62],
  openD:     [38,45,50,54,57,62],
  dadgad:    [38,45,50,55,57,62],
  halfDown:  [39,44,49,54,58,63],
  fullDown:  [38,43,48,53,57,62],
  openE:     [40,47,52,56,59,64],
  openA:     [40,45,52,57,61,64],
};
const TUNING_LABELS = {
  standard: ['E','A','D','G','B','E'],
  dropD: ['D','A','D','G','B','E'],
  openG: ['D','G','D','G','B','D'],
  openD: ['D','A','D','F#','A','D'],
  dadgad: ['D','A','D','G','A','D'],
  halfDown: ['Eb','Ab','Db','Gb','Bb','Eb'],
  fullDown: ['D','G','C','F','A','D'],
  openE: ['E','B','E','G#','B','E'],
  openA: ['E','A','E','A','C#','E'],
};

// ===== SCALE DEFINITIONS =====
const SCALES = {
  'Major (Ionian)':          { intervals: [0,2,4,5,7,9,11], category: 'Major Modes' },
  'Dorian':                  { intervals: [0,2,3,5,7,9,10], category: 'Major Modes' },
  'Phrygian':                { intervals: [0,1,3,5,7,8,10], category: 'Major Modes' },
  'Lydian':                  { intervals: [0,2,4,6,7,9,11], category: 'Major Modes' },
  'Mixolydian':              { intervals: [0,2,4,5,7,9,10], category: 'Major Modes' },
  'Natural Minor (Aeolian)': { intervals: [0,2,3,5,7,8,10], category: 'Major Modes' },
  'Locrian':                 { intervals: [0,1,3,5,6,8,10], category: 'Major Modes' },

  'Major Pentatonic':     { intervals: [0,2,4,7,9], category: 'Pentatonic & Blues' },
  'Minor Pentatonic':     { intervals: [0,3,5,7,10], category: 'Pentatonic & Blues' },
  'Blues':                 { intervals: [0,3,5,6,7,10], category: 'Pentatonic & Blues' },
  'Major Blues':           { intervals: [0,2,3,4,7,9], category: 'Pentatonic & Blues' },

  'Harmonic Minor':       { intervals: [0,2,3,5,7,8,11], category: 'Harmonic & Melodic' },
  'Melodic Minor (Asc)':  { intervals: [0,2,3,5,7,9,11], category: 'Harmonic & Melodic' },
  'Phrygian Dominant':    { intervals: [0,1,4,5,7,8,10], category: 'Harmonic & Melodic' },
  'Lydian Dominant':      { intervals: [0,2,4,6,7,9,10], category: 'Harmonic & Melodic' },
  'Super Locrian':        { intervals: [0,1,3,4,6,8,10], category: 'Harmonic & Melodic' },
  'Lydian Augmented':     { intervals: [0,2,4,6,8,9,11], category: 'Harmonic & Melodic' },
  'Dorian b2':            { intervals: [0,1,3,5,7,9,10], category: 'Harmonic & Melodic' },
  'Mixolydian b6':        { intervals: [0,2,4,5,7,8,10], category: 'Harmonic & Melodic' },
  'Locrian #2':           { intervals: [0,2,3,5,6,8,10], category: 'Harmonic & Melodic' },

  'Whole Tone':           { intervals: [0,2,4,6,8,10], category: 'Symmetric & Jazz' },
  'Diminished (H-W)':     { intervals: [0,1,3,4,6,7,9,10], category: 'Symmetric & Jazz' },
  'Diminished (W-H)':     { intervals: [0,2,3,5,6,8,9,11], category: 'Symmetric & Jazz' },
  'Chromatic':            { intervals: [0,1,2,3,4,5,6,7,8,9,10,11], category: 'Symmetric & Jazz' },
  'Bebop Dominant':       { intervals: [0,2,4,5,7,9,10,11], category: 'Symmetric & Jazz' },
  'Bebop Major':          { intervals: [0,2,4,5,7,8,9,11], category: 'Symmetric & Jazz' },
  'Bebop Minor':          { intervals: [0,2,3,4,5,7,9,10], category: 'Symmetric & Jazz' },
  'Neapolitan Minor':     { intervals: [0,1,3,5,7,8,11], category: 'Symmetric & Jazz' },
  'Neapolitan Major':     { intervals: [0,1,3,5,7,9,11], category: 'Symmetric & Jazz' },
  'Enigmatic':            { intervals: [0,1,4,6,8,10,11], category: 'Symmetric & Jazz' },
  'Spanish Phrygian':     { intervals: [0,1,4,5,7,8,10], category: 'Symmetric & Jazz' },
};

// ===== CHORD DEFINITIONS =====
// Intervals from root (semitones, mod 12)
const CHORDS = {
  // Triads
  'Major':        { intervals: [0,4,7],    formula: '1 3 5',      category: 'Triads' },
  'Minor':        { intervals: [0,3,7],    formula: '1 b3 5',     category: 'Triads' },
  'Diminished':   { intervals: [0,3,6],    formula: '1 b3 b5',    category: 'Triads' },
  'Augmented':    { intervals: [0,4,8],    formula: '1 3 #5',     category: 'Triads' },
  'sus2':         { intervals: [0,2,7],    formula: '1 2 5',      category: 'Triads' },
  'sus4':         { intervals: [0,5,7],    formula: '1 4 5',      category: 'Triads' },
  'Power (5)':    { intervals: [0,7],      formula: '1 5',        category: 'Triads' },

  // Seventh Chords
  'Dominant 7':   { intervals: [0,4,7,10], formula: '1 3 5 b7',   category: 'Seventh Chords' },
  'Major 7':      { intervals: [0,4,7,11], formula: '1 3 5 7',    category: 'Seventh Chords' },
  'Minor 7':      { intervals: [0,3,7,10], formula: '1 b3 5 b7',  category: 'Seventh Chords' },
  'Min(Maj7)':    { intervals: [0,3,7,11], formula: '1 b3 5 7',   category: 'Seventh Chords' },
  'Dim 7':        { intervals: [0,3,6,9],  formula: '1 b3 b5 bb7',category: 'Seventh Chords' },
  'Half-Dim 7':   { intervals: [0,3,6,10], formula: '1 b3 b5 b7', category: 'Seventh Chords' },
  'Aug 7':        { intervals: [0,4,8,10], formula: '1 3 #5 b7',  category: 'Seventh Chords' },
  'Aug Maj7':     { intervals: [0,4,8,11], formula: '1 3 #5 7',   category: 'Seventh Chords' },
  '7sus4':        { intervals: [0,5,7,10], formula: '1 4 5 b7',   category: 'Seventh Chords' },
  '7sus2':        { intervals: [0,2,7,10], formula: '1 2 5 b7',   category: 'Seventh Chords' },

  // Sixth Chords
  'Major 6':      { intervals: [0,4,7,9],  formula: '1 3 5 6',    category: 'Sixth Chords' },
  'Minor 6':      { intervals: [0,3,7,9],  formula: '1 b3 5 6',   category: 'Sixth Chords' },
  '6/9':          { intervals: [0,2,4,7,9],formula: '1 2 3 5 6',  category: 'Sixth Chords' },

  // Extended Chords
  'Dom 9':        { intervals: [0,2,4,7,10],  formula: '1 2 3 5 b7',   category: 'Extended' },
  'Major 9':      { intervals: [0,2,4,7,11],  formula: '1 2 3 5 7',    category: 'Extended' },
  'Minor 9':      { intervals: [0,2,3,7,10],  formula: '1 2 b3 5 b7',  category: 'Extended' },
  'add9':         { intervals: [0,2,4,7],     formula: '1 2 3 5',      category: 'Extended' },
  'Dom 11':       { intervals: [0,2,4,5,7,10],formula: '1 2 3 4 5 b7', category: 'Extended' },
  'Minor 11':     { intervals: [0,2,3,5,7,10],formula: '1 2 b3 4 5 b7',category: 'Extended' },
  'Dom 13':       { intervals: [0,2,4,7,9,10],formula: '1 2 3 5 6 b7', category: 'Extended' },
  'Major 13':     { intervals: [0,2,4,7,9,11],formula: '1 2 3 5 6 7',  category: 'Extended' },
  'Minor 13':     { intervals: [0,2,3,7,9,10],formula: '1 2 b3 5 6 b7',category: 'Extended' },

  // Altered Chords
  '7b9':          { intervals: [0,1,4,7,10],  formula: '1 b2 3 5 b7',  category: 'Altered' },
  '7#9':          { intervals: [0,3,4,7,10],  formula: '1 #2 3 5 b7',  category: 'Altered' },
  '7b5':          { intervals: [0,4,6,10],    formula: '1 3 b5 b7',    category: 'Altered' },
  '7#5':          { intervals: [0,4,8,10],    formula: '1 3 #5 b7',    category: 'Altered' },
  '7b9b5':        { intervals: [0,1,4,6,10],  formula: '1 b2 3 b5 b7', category: 'Altered' },
  '7#9b5':        { intervals: [0,3,4,6,10],  formula: '1 #2 3 b5 b7', category: 'Altered' },
  '7alt':         { intervals: [0,1,3,4,6,8,10], formula: '1 b2 #2 3 b5 #5 b7', category: 'Altered' },
};

// Scale colors
const SCALE_COLORS = [
  '#4FC3F7', '#FF8A65', '#81C784', '#CE93D8',
  '#F06292', '#4DD0E1', '#FFD54F', '#A1887F',
];

// Chord colors (distinct warm/vivid palette)
const CHORD_COLORS = [
  '#e84393', '#00cec9', '#fdcb6e', '#6c5ce7',
  '#e17055', '#00b894', '#fab1a0', '#a29bfe',
];

// Interval role colours â€” used on fretboard & chord diagrams for per-note differentiation
// Root=red, 3rds=amber, 5th=teal, 7ths=violet, 2nds=sky, 4th=mint, tritone=orange, 6ths=lime
const CHORD_INTERVAL_COLORS = {
  0:  '#ff4757', // Root        â€” red
  1:  '#74b9ff', // b2          â€” sky blue
  2:  '#74b9ff', // M2/sus2     â€” sky blue
  3:  '#fdcb6e', // m3          â€” amber
  4:  '#fdcb6e', // M3          â€” amber
  5:  '#55efc4', // P4/sus4     â€” mint
  6:  '#e17055', // Tritone     â€” orange
  7:  '#00cec9', // P5          â€” teal
  8:  '#a3cb38', // b6          â€” lime
  9:  '#a3cb38', // M6          â€” lime
  10: '#a29bfe', // b7          â€” violet
  11: '#a29bfe', // M7          â€” violet
};

// Highlight group colors for triads/dyads â€” max contrast, bold, unmistakable
const HIGHLIGHT_COLORS = [
  '#ff1744', // vivid red
  '#00e5ff', // electric cyan
  '#ffea00', // bright yellow
  '#76ff03', // lime green
  '#d500f9', // magenta
  '#ff9100', // orange
  '#448aff', // blue
  '#f50057', // hot pink
  '#00e676', // green
  '#651fff', // deep purple
  '#ff3d00', // red-orange
  '#18ffff', // aqua
];

// ===== SIMPLE MODE WHITELISTS =====
const SIMPLE_SCALES = new Set([
  'Major (Ionian)', 'Natural Minor (Aeolian)',
  'Major Pentatonic', 'Minor Pentatonic', 'Blues', 'Major Blues',
  'Harmonic Minor',
]);
const SIMPLE_SCALE_CAT_NAMES = {
  'Major Modes': 'Essentials',
  'Pentatonic & Blues': 'Pentatonic & Blues',
  'Harmonic & Melodic': 'Harmonic',
};
const SIMPLE_CHORDS = new Set([
  'Major', 'Minor', 'Diminished', 'Augmented', 'sus2', 'sus4', 'Power (5)',
  'Dominant 7', 'Major 7', 'Minor 7',
]);
const SIMPLE_CHORD_CAT_NAMES = {
  'Triads': 'Chords',
  'Seventh Chords': 'Extended Chords',
};
const SIMPLE_TUNINGS = new Set(['standard', 'dropD', 'halfDown', 'fullDown']);

// ===== APP STATE =====
let state = {
  rootNote: 0,
  selectedScales: [],
  selectedChords: [],
  flipH: false,
  flipV: true,
  labelMode: 'notes',
  tuning: 'standard',
  numFrets: 15,
  activeTab: 'scales',
  cycleOriginRoot: 0,
  vertical: false,
  noteAnim: {},
  animating: false,
  highlightGroups: [], // [{notes:[noteIdx,...], color, label, type:'triad'|'dyad'}]
  voicingIndex: 0, // current voicing being displayed
  cachedVoicings: [], // [{points, color, noteData}] - computed voicings for current highlight
  simpleMode: false,
  tabBeats: [],
  tabCurrentBeat: -1,
  tabPlaying: false,
  tabLoop: false,
  chordShapeVoicings: {}, // cacheKey -> voicings array
  chordShapeIndex: {},    // cacheKey -> current index
  scalePositionIndex: 0,  // current position (0-4)
  scalePositionCache: {}, // cacheKey -> [{vi,f}[]]
};

// ===== CANVAS =====
const canvas = document.getElementById('fretboard');
const ctx = canvas.getContext('2d');
let dpr = window.devicePixelRatio || 1;

// Click a note dot to hear it
canvas.style.cursor = 'pointer';
canvas.addEventListener('click', function(e) {
  const rect = canvas.getBoundingClientRect();
  const cx = (e.clientX - rect.left) * (canvas.width / rect.width / dpr);
  const cy = (e.clientY - rect.top) * (canvas.height / rect.height / dpr);
  let best = null, bestD = FB.noteRadius * 2.5;
  for (const n of drawnNoteHits) {
    const d = Math.hypot(n.x - cx, n.y - cy);
    if (d < bestD) { bestD = d; best = n; }
  }
  if (best) playFretboardNote(best.vi, best.f);
});

const FB = {
  paddingLeft: 60,
  paddingRight: 30,
  paddingTop: 40,
  paddingBottom: 40,
  stringSpacing: 32,
  nutWidth: 8,
  noteRadius: 13,
};

function getCanvasWidth() {
  return Math.max(800, canvas.parentElement.clientWidth - 10);
}

function resizeCanvas() {
  const w = getCanvasWidth();
  let h;
  if (state.vertical) {
    // Vertical mode: taller canvas
    h = Math.max(500, Math.min(900, window.innerHeight - 200));
  } else {
    h = FB.paddingTop + FB.paddingBottom + 5 * FB.stringSpacing + 30;
  }
  canvas.style.width = w + 'px';
  canvas.style.height = h + 'px';
  canvas.width = w * dpr;
  canvas.height = h * dpr;
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  return { w, h };
}

function getFretPositions(numFrets, totalWidth) {
  const positions = [0];
  const scaleLength = totalWidth * 1.6;
  for (let i = 1; i <= numFrets; i++) {
    positions.push(scaleLength * (1 - Math.pow(2, -i / 12)));
  }
  const maxPos = positions[positions.length - 1];
  return positions.map(p => (p / maxPos) * totalWidth);
}

function getInterval(root, note) {
  return (note - root + 12) % 12;
}

// Get which scales a note belongs to
function getScaleHits(noteIndex) {
  const results = [];
  for (const name of state.selectedScales) {
    const iv = getInterval(state.rootNote, noteIndex);
    if (SCALES[name].intervals.includes(iv)) {
      const ci = state.selectedScales.indexOf(name) % SCALE_COLORS.length;
      results.push({ name, color: SCALE_COLORS[ci], type: 'scale', interval: iv });
    }
  }
  return results;
}

// Get which chords a note belongs to
function getChordHits(noteIndex) {
  const results = [];
  for (const name of state.selectedChords) {
    const iv = getInterval(state.rootNote, noteIndex);
    if (CHORDS[name].intervals.includes(iv)) {
      const ci = state.selectedChords.indexOf(name) % CHORD_COLORS.length;
      results.push({ name, color: CHORD_COLORS[ci], type: 'chord', interval: iv });
    }
  }
  return results;
}

// ===== ANIMATION =====
let animStartTime = 0;
const ANIM_DURATION = 400; // ms per note cascade
const ANIM_STAGGER = 30;  // ms delay per fret

function triggerNoteAnim() {
  animStartTime = performance.now();
  if (!state.animating) {
    state.animating = true;
    requestAnimationFrame(animLoop);
  }
}

function animLoop(now) {
  draw(now);
  const elapsed = now - animStartTime;
  const maxTime = ANIM_DURATION + ANIM_STAGGER * (state.numFrets + 6);
  if (elapsed < maxTime) {
    requestAnimationFrame(animLoop);
  } else {
    state.animating = false;
  }
}

function getNoteAnimProgress(fret, stringVi, now) {
  if (!now || !animStartTime) return 1;
  const elapsed = now - animStartTime;
  const delay = (fret + stringVi * 0.5) * ANIM_STAGGER;
  const t = Math.max(0, Math.min(1, (elapsed - delay) / ANIM_DURATION));
  // Ease out bounce
  if (t < 1) {
    const ease = 1 - Math.pow(1 - t, 3);
    return ease;
  }
  return 1;
}

// ===== DRAWING =====
function draw(now) {
  drawnNoteHits.length = 0; // reset click targets each frame
  const vert = state.vertical;
  const { w, h } = resizeCanvas();
  ctx.clearRect(0, 0, w, h);

  const tuningMidi = TUNINGS[state.tuning];
  const tuningLabels = TUNING_LABELS[state.tuning];
  const numStrings = 6;

  let stringOrder = [0,1,2,3,4,5];
  if (state.flipV) stringOrder = [...stringOrder].reverse();
  const flipH = state.flipH;

  // --- COORDINATE SYSTEM ---
  // Horizontal: frets along X, strings along Y
  // Vertical: frets along Y (top=nut), strings along X
  const VFB = {
    stringLabelSize: 30,
    fretLabelSize: 25,
    pad: 20,
  };

  let fretAreaLength, stringAreaLength;
  if (vert) {
    stringAreaLength = Math.min(220, w - VFB.stringLabelSize - VFB.pad * 2);
    fretAreaLength = h - FB.paddingTop - VFB.fretLabelSize - VFB.pad;
  } else {
    fretAreaLength = w - FB.paddingLeft - FB.paddingRight;
    stringAreaLength = 5 * FB.stringSpacing;
  }

  const fretPositions = getFretPositions(state.numFrets, fretAreaLength);
  const stringSpacing = vert ? (stringAreaLength / (numStrings - 1)) : FB.stringSpacing;

  // Position helpers
  function getFretCoord(fretPos) {
    if (vert) {
      return FB.paddingTop + fretPos;
    } else {
      return flipH ? (w - FB.paddingRight - fretPos) : (FB.paddingLeft + fretPos);
    }
  }
  function getStringCoord(vi) {
    if (vert) {
      const neckWidth = stringSpacing * (numStrings - 1);
      const base = (w - neckWidth) / 2; // center the neck
      return flipH ? (w - base - vi * stringSpacing) : (base + vi * stringSpacing);
    } else {
      return FB.paddingTop + vi * FB.stringSpacing;
    }
  }
  function getNoteXY(fretPos, vi) {
    if (vert) return { x: getStringCoord(vi), y: getFretCoord(fretPos) };
    return { x: getFretCoord(fretPos), y: getStringCoord(vi) };
  }

  // Fretboard bounds
  let fbX1, fbY1, fbX2, fbY2;
  if (vert) {
    fbX1 = getStringCoord(0) - 14;
    fbX2 = getStringCoord(numStrings - 1) + 14;
    if (fbX1 > fbX2) { const t = fbX1; fbX1 = fbX2; fbX2 = t; }
    fbY1 = FB.paddingTop;
    fbY2 = FB.paddingTop + fretAreaLength;
  } else {
    const fbLeft = flipH ? FB.paddingRight : FB.paddingLeft;
    const fbRight = flipH ? (w - FB.paddingLeft) : (w - FB.paddingRight);
    fbX1 = Math.min(fbLeft, fbRight);
    fbX2 = Math.max(fbLeft, fbRight);
    fbY1 = FB.paddingTop - 14;
    fbY2 = FB.paddingTop + (numStrings - 1) * FB.stringSpacing + 14;
  }

  // Wood background
  const woodGrad = vert
    ? ctx.createLinearGradient(fbX1, 0, fbX2, 0)
    : ctx.createLinearGradient(0, fbY1, 0, fbY2);
  woodGrad.addColorStop(0, '#4a3428');
  woodGrad.addColorStop(0.3, '#5c3d2e');
  woodGrad.addColorStop(0.5, '#6b4535');
  woodGrad.addColorStop(0.7, '#5c3d2e');
  woodGrad.addColorStop(1, '#4a3428');
  ctx.fillStyle = woodGrad;
  ctx.beginPath();
  ctx.roundRect(fbX1, fbY1, fbX2 - fbX1, fbY2 - fbY1, 6);
  ctx.fill();

  // Wood grain
  ctx.save();
  ctx.globalAlpha = 0.025;
  ctx.strokeStyle = '#fff';
  ctx.lineWidth = 0.5;
  for (let i = 0; i < 25; i++) {
    if (vert) {
      const x = fbX1 + (fbX2 - fbX1) * (i / 25);
      ctx.beginPath(); ctx.moveTo(x, fbY1); ctx.lineTo(x, fbY2); ctx.stroke();
    } else {
      const y = fbY1 + (fbY2 - fbY1) * (i / 25);
      ctx.beginPath(); ctx.moveTo(fbX1, y); ctx.lineTo(fbX2, y); ctx.stroke();
    }
  }
  ctx.restore();

  // Nut
  ctx.fillStyle = '#f0ead6';
  ctx.shadowColor = '#00000040';
  ctx.shadowBlur = 4;
  if (vert) {
    ctx.fillRect(fbX1, fbY1 - FB.nutWidth, fbX2 - fbX1, FB.nutWidth);
  } else {
    const nutX = flipH ? (w - FB.paddingRight) : FB.paddingLeft;
    ctx.fillRect(nutX - (flipH ? 0 : FB.nutWidth), fbY1, FB.nutWidth, fbY2 - fbY1);
  }
  ctx.shadowBlur = 0;

  // Fret markers
  const dotFrets = [3,5,7,9,12,15,17,19,21,24];
  const doubleDotFrets = [12,24];
  const midString = vert
    ? (getStringCoord(0) + getStringCoord(numStrings - 1)) / 2
    : FB.paddingTop + ((numStrings-1) * FB.stringSpacing) / 2;
  for (let f = 1; f <= state.numFrets; f++) {
    if (!dotFrets.includes(f)) continue;
    const midFret = (fretPositions[f-1] + fretPositions[f]) / 2;
    const fc = getFretCoord(midFret);
    ctx.fillStyle = 'rgba(255,255,255,0.08)';
    if (doubleDotFrets.includes(f)) {
      const off = stringSpacing * 1.2;
      if (vert) {
        ctx.beginPath(); ctx.arc(midString - off, fc, 6, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(midString + off, fc, 6, 0, Math.PI*2); ctx.fill();
      } else {
        ctx.beginPath(); ctx.arc(fc, midString - off, 6, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(fc, midString + off, 6, 0, Math.PI*2); ctx.fill();
      }
    } else {
      if (vert) {
        ctx.beginPath(); ctx.arc(midString, fc, 6, 0, Math.PI*2); ctx.fill();
      } else {
        ctx.beginPath(); ctx.arc(fc, midString, 6, 0, Math.PI*2); ctx.fill();
      }
    }
  }

  // Frets
  for (let f = 1; f <= state.numFrets; f++) {
    const fc = getFretCoord(fretPositions[f]);
    if (vert) {
      const fg = ctx.createLinearGradient(0, fc-1, 0, fc+1);
      fg.addColorStop(0, '#888'); fg.addColorStop(0.5, '#d0d0d0'); fg.addColorStop(1, '#888');
      ctx.strokeStyle = fg; ctx.lineWidth = 2.5;
      ctx.beginPath(); ctx.moveTo(fbX1, fc); ctx.lineTo(fbX2, fc); ctx.stroke();
    } else {
      const fg = ctx.createLinearGradient(fc-1, 0, fc+1, 0);
      fg.addColorStop(0, '#888'); fg.addColorStop(0.5, '#d0d0d0'); fg.addColorStop(1, '#888');
      ctx.strokeStyle = fg; ctx.lineWidth = 2.5;
      ctx.beginPath(); ctx.moveTo(fc, fbY1); ctx.lineTo(fc, fbY2); ctx.stroke();
    }
  }

  // Strings
  for (let vi = 0; vi < numStrings; vi++) {
    const si = stringOrder[vi];
    const sc = getStringCoord(vi);
    const thickness = 3.5 - si * 0.45;
    ctx.strokeStyle = si < 3 ? `rgba(180,170,150,${0.6+si*0.05})` : `rgba(210,205,195,${0.6+si*0.05})`;
    ctx.lineWidth = thickness;
    if (vert) {
      ctx.beginPath(); ctx.moveTo(sc, fbY1); ctx.lineTo(sc, fbY2); ctx.stroke();
      ctx.strokeStyle = `rgba(255,255,255,${0.08+si*0.02})`; ctx.lineWidth = 0.5;
      ctx.beginPath(); ctx.moveTo(sc-thickness/3, fbY1); ctx.lineTo(sc-thickness/3, fbY2); ctx.stroke();
    } else {
      ctx.beginPath(); ctx.moveTo(fbX1, sc); ctx.lineTo(fbX2, sc); ctx.stroke();
      ctx.strokeStyle = `rgba(255,255,255,${0.08+si*0.02})`; ctx.lineWidth = 0.5;
      ctx.beginPath(); ctx.moveTo(fbX1, sc-thickness/3); ctx.lineTo(fbX2, sc-thickness/3); ctx.stroke();
    }
  }

  // Fret numbers
  ctx.font = '500 11px "JetBrains Mono", monospace';
  ctx.fillStyle = '#555570';
  ctx.textAlign = 'center';
  for (let f = 1; f <= state.numFrets; f++) {
    const midFret = (fretPositions[f-1] + fretPositions[f]) / 2;
    const fc = getFretCoord(midFret);
    if (vert) {
      ctx.textAlign = 'right';
      ctx.fillText(f, fbX1 - 8, fc + 4);
    } else {
      ctx.textAlign = 'center';
      ctx.fillText(f, fc, fbY2 + 20);
    }
  }

  // String labels
  ctx.font = '600 12px "JetBrains Mono", monospace';
  for (let vi = 0; vi < numStrings; vi++) {
    const si = stringOrder[vi];
    const sc = getStringCoord(vi);
    ctx.fillStyle = '#8888aa';
    if (vert) {
      ctx.textAlign = 'center';
      ctx.fillText(tuningLabels[si], sc, fbY1 - FB.nutWidth - 6);
    } else {
      ctx.textAlign = flipH ? 'left' : 'right';
      ctx.fillText(tuningLabels[si], flipH ? (w-FB.paddingRight+14) : (FB.paddingLeft-14), sc+4);
    }
  }

  // ===== DRAW NOTES =====
  const hasScales = state.selectedScales.length > 0;
  const hasChords = state.selectedChords.length > 0;
  const rootOnly = !hasScales && !hasChords;

  // ===== BUILD ACTIVE VOICING LOOKUP =====
  // For each chord, get the currently-selected voicing (vi:fret pairs) so we can
  // highlight those exact notes on the fretboard and dim everything else.
  const activeVoicingKeys = new Set(); // "displayVi:f" for notes in current voicing
  const hasActiveVoicing = hasChords && !rootOnly && state.selectedChords.length > 0 &&
    state.selectedChords.some(name => {
      const key = name + '_' + state.rootNote + '_' + state.tuning;
      return state.chordShapeVoicings[key] && state.chordShapeVoicings[key].length > 0;
    });
  if (hasActiveVoicing) {
    // Standard vi â†’ physical string (diagrams always use [0,1,2,3,4,5])
    // Physical string â†’ display vi under current flipV
    const displayOrder = state.flipV ? [5,4,3,2,1,0] : [0,1,2,3,4,5];
    state.selectedChords.forEach(name => {
      const key = name + '_' + state.rootNote + '_' + state.tuning;
      const voicings = state.chordShapeVoicings[key];
      if (!voicings || !voicings.length) return;
      const idx = state.chordShapeIndex[key] || 0;
      voicings[idx].forEach(({ vi, f }) => {
        // vi is standard (physical string = vi), map to display vi
        const displayVi = displayOrder.indexOf(vi);
        if (displayVi !== -1) activeVoicingKeys.add(displayVi + ':' + f);
      });
    });
  }

  // ===== BUILD ACTIVE SCALE POSITION LOOKUP =====
  const activeScalePosKeys = new Set(); // "vi:f" for notes in current scale position
  const hasActiveScalePos = hasScales && state.selectedScales.length > 0;
  if (hasActiveScalePos) {
    const cacheKey = state.selectedScales[0] + '_' + state.rootNote + '_' + state.tuning;
    if (!state.scalePositionCache[cacheKey]) {
      const scale = SCALES[state.selectedScales[0]];
      state.scalePositionCache[cacheKey] = computeScalePositions(scale.intervals, state.rootNote, TUNINGS[state.tuning], state.numFrets);
      state.scalePositionIndex = 0;
    }
    const positions = state.scalePositionCache[cacheKey];
    if (positions && positions.length > 0) {
      const idx = Math.max(0, Math.min(state.scalePositionIndex, positions.length - 1));
      positions[idx].forEach(({ vi: physVi, f }) => {
        // physVi is physical string index (0=lowE); map to display vi under current flipV
        const displayOrder = state.flipV ? [5,4,3,2,1,0] : [0,1,2,3,4,5];
        const displayVi = displayOrder.indexOf(physVi);
        if (displayVi !== -1) activeScalePosKeys.add(displayVi + ':' + f);
      });
    }
  }

  for (let vi = 0; vi < numStrings; vi++) {
    const si = stringOrder[vi];

    for (let f = 0; f <= state.numFrets; f++) {
      const noteIndex = (tuningMidi[si] + f) % 12;
      const isRoot = getInterval(state.rootNote, noteIndex) === 0;
      const scaleHits = getScaleHits(noteIndex);
      const chordHits = getChordHits(noteIndex);
      if (rootOnly && !isRoot) continue;
      if (!rootOnly && scaleHits.length === 0 && chordHits.length === 0) continue;

      // Position
      let pos;
      if (f === 0) {
        if (vert) {
          pos = { x: getStringCoord(vi), y: fbY1 - FB.nutWidth / 2 };
        } else {
          const nutX = flipH ? (w - FB.paddingRight) : FB.paddingLeft;
          pos = { x: flipH ? nutX + FB.nutWidth/2 : nutX - FB.nutWidth/2, y: getStringCoord(vi) };
        }
      } else {
        const midFret = (fretPositions[f-1] + fretPositions[f]) / 2;
        pos = getNoteXY(midFret, vi);
      }

      let { x, y } = pos;

      // Animation: falling effect in vertical mode, scale-in otherwise
      const animT = getNoteAnimProgress(f, vi, now);
      if (animT <= 0) continue;

      const r = FB.noteRadius * animT;
      const interval = getInterval(state.rootNote, noteIndex);

      // Vertical fall offset
      let yOffset = 0;
      if (vert && animT < 1) {
        yOffset = -40 * (1 - animT);
      }
      const drawX = x;
      const drawY = y + yOffset;
      // If a chord voicing is active, only show notes in that voicing â€” hide all others
      if (hasActiveVoicing && chordHits.length > 0 && !activeVoicingKeys.has(vi + ':' + f)) continue;
      // If a scale position is active, only show scale notes in that position
      if (hasActiveScalePos && scaleHits.length > 0 && !activeScalePosKeys.has(vi + ':' + f)) continue;
      const drawAlpha = Math.min(1, animT * 1.5);

      // Record hit area for click-to-play
      if (animT >= 1) drawnNoteHits.push({ vi, f, x: drawX, y: drawY });

      ctx.globalAlpha = drawAlpha;

      // Root-only mode
      if (rootOnly && isRoot) {
        ctx.shadowColor = '#6c5ce780';
        ctx.shadowBlur = 14 * animT;
        ctx.fillStyle = '#6c5ce7';
        ctx.beginPath();
        const dr = r + 1;
        ctx.moveTo(drawX, drawY-dr); ctx.lineTo(drawX+dr, drawY); ctx.lineTo(drawX, drawY+dr); ctx.lineTo(drawX-dr, drawY);
        ctx.closePath(); ctx.fill();
        ctx.strokeStyle = '#a855f7'; ctx.lineWidth = 2; ctx.stroke();
        ctx.shadowBlur = 0;
        if (animT > 0.5) {
          ctx.font = '700 10px "JetBrains Mono", monospace';
          ctx.fillStyle = '#fff';
          ctx.textAlign = 'center';
          ctx.fillText(NOTES[noteIndex], drawX, drawY + 3.5);
        }
        ctx.globalAlpha = 1;
        continue;
      }

      // Scale fill color
      let scaleFill = null;
      if (scaleHits.length > 1) scaleFill = '#ffd700';
      else if (scaleHits.length === 1) scaleFill = CHORD_INTERVAL_COLORS[scaleHits[0].interval] ?? scaleHits[0].color;

      // Chord ring color â€” use interval role colour for single chord, gold for multi-chord overlap
      let chordRingColor = null;
      if (chordHits.length > 1) chordRingColor = '#ffd700';
      else if (chordHits.length === 1) chordRingColor = CHORD_INTERVAL_COLORS[chordHits[0].interval] ?? chordHits[0].color;

      const isScaleCommon = scaleHits.length > 1 && state.selectedScales.length > 1;
      const isChordCommon = chordHits.length > 1 && state.selectedChords.length > 1;

      // Scale note
      if (scaleFill) {
        if (isRoot) { ctx.shadowColor = '#ff475780'; ctx.shadowBlur = 14 * animT; }
        else if (isScaleCommon) { ctx.shadowColor = '#ffd70060'; ctx.shadowBlur = 12 * animT; }
        else { ctx.shadowColor = scaleFill + '50'; ctx.shadowBlur = 8 * animT; }

        if (isRoot) {
          ctx.fillStyle = scaleFill;
          ctx.beginPath();
          const dr = r + 1;
          ctx.moveTo(drawX, drawY-dr); ctx.lineTo(drawX+dr, drawY); ctx.lineTo(drawX, drawY+dr); ctx.lineTo(drawX-dr, drawY);
          ctx.closePath(); ctx.fill();
          ctx.strokeStyle = '#ff4757'; ctx.lineWidth = 2; ctx.stroke();
        } else {
          ctx.fillStyle = scaleFill;
          ctx.beginPath(); ctx.arc(drawX, drawY, r, 0, Math.PI*2); ctx.fill();
          if (isScaleCommon) { ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; ctx.stroke(); }
        }
        ctx.shadowBlur = 0;
      }

      // Chord-only note
      if (!scaleFill && chordRingColor) {
        if (isRoot) {
          ctx.shadowColor = '#ff475780'; ctx.shadowBlur = 14 * animT;
          ctx.fillStyle = chordRingColor;
          ctx.beginPath();
          const dr = r + 1;
          ctx.moveTo(drawX, drawY-dr); ctx.lineTo(drawX+dr, drawY); ctx.lineTo(drawX, drawY+dr); ctx.lineTo(drawX-dr, drawY);
          ctx.closePath(); ctx.fill();
          ctx.strokeStyle = '#ff4757'; ctx.lineWidth = 2; ctx.stroke();
        } else {
          ctx.shadowColor = chordRingColor + '60'; ctx.shadowBlur = 10 * animT;
          ctx.fillStyle = chordRingColor + '30';
          ctx.beginPath(); ctx.arc(drawX, drawY, r, 0, Math.PI*2); ctx.fill();
          ctx.strokeStyle = chordRingColor; ctx.lineWidth = 2.5; ctx.stroke();
        }
        ctx.shadowBlur = 0;
      }

      // Chord ring overlay
      if (scaleFill && chordRingColor) {
        ctx.shadowBlur = 0;
        const ringSize = r + 5;
        ctx.strokeStyle = chordRingColor; ctx.lineWidth = 2.5;
        ctx.beginPath();
        ctx.roundRect(drawX - ringSize, drawY - ringSize, ringSize*2, ringSize*2, 4);
        ctx.stroke();
        if (isChordCommon) { ctx.strokeStyle = '#fff'; ctx.lineWidth = 1; ctx.stroke(); }
      }

      // Label
      if (animT > 0.5) {
        const textColor = scaleFill ? (isRoot || isScaleCommon ? '#000' : '#000000cc') : (chordRingColor ? '#fff' : '#000');
        ctx.textAlign = 'center';

        if (scaleFill && state.labelMode === 'notes') {
          // Two-line: note name (top) + degree number (bottom)
          const noteName = NOTES[noteIndex];
          const degName = DEGREE_NAMES[interval];
          ctx.font = `700 ${noteName.length > 1 ? '8' : '9'}px "JetBrains Mono", monospace`;
          ctx.fillStyle = textColor;
          ctx.fillText(noteName, drawX, drawY - 0.5);
          ctx.font = `600 7px "JetBrains Mono", monospace`;
          ctx.fillText(degName, drawX, drawY + 7.5);
        } else {
          let label = '';
          if (state.labelMode === 'notes') label = NOTES[noteIndex];
          else if (state.labelMode === 'intervals') label = INTERVAL_NAMES[interval];
          else label = DEGREE_NAMES[interval];
          ctx.font = `${isRoot ? '700' : '600'} ${label.length > 2 ? '9' : '10'}px "JetBrains Mono", monospace`;
          ctx.fillStyle = textColor;
          ctx.fillText(label, drawX, drawY + 3.5);
        }

        // Count badge: show how many scales+chords share this note
        const totalHits = scaleHits.length + chordHits.length;
        if (totalHits > 1) {
          const bx = drawX + r - 2;
          const by = drawY - r + 2;
          const br = 7;
          // Badge background
          ctx.fillStyle = totalHits >= 4 ? '#ff4757' : totalHits >= 3 ? '#ffa502' : '#ffffff';
          ctx.strokeStyle = '#000';
          ctx.lineWidth = 1.5;
          ctx.beginPath(); ctx.arc(bx, by, br, 0, Math.PI*2); ctx.fill(); ctx.stroke();
          // Badge number
          ctx.font = '700 8px "JetBrains Mono", monospace';
          ctx.fillStyle = totalHits >= 3 ? '#fff' : '#000';
          ctx.textAlign = 'center';
          ctx.fillText(totalHits, bx, by + 3);
        }
      }

      ctx.globalAlpha = 1;
    }
  }

  // ===== TAB BEAT OVERLAY =====
  if (state.tabCurrentBeat >= 0 && state.tabBeats.length > 0) {
    const beat = state.tabBeats[state.tabCurrentBeat];
    if (beat) {
      beat.forEach(note => {
        if (note.fret === null) return; // muted
        const vi = stringOrder.indexOf(note.string);
        if (vi === -1) return;
        let pos;
        if (note.fret === 0) {
          if (vert) {
            pos = { x: getStringCoord(vi), y: fbY1 - FB.nutWidth / 2 };
          } else {
            const nutX = flipH ? (w - FB.paddingRight) : FB.paddingLeft;
            pos = { x: flipH ? nutX + FB.nutWidth/2 : nutX - FB.nutWidth/2, y: getStringCoord(vi) };
          }
        } else {
          const midFret = (fretPositions[note.fret - 1] + fretPositions[note.fret]) / 2;
          pos = getNoteXY(midFret, vi);
        }
        const noteIndex = (tuningMidi[note.string] + note.fret) % 12;
        const r = FB.noteRadius + 5;
        ctx.shadowColor = '#00ff88';
        ctx.shadowBlur = 18;
        ctx.strokeStyle = '#00ff88';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(pos.x, pos.y, r, 0, Math.PI * 2);
        ctx.stroke();
        ctx.shadowBlur = 0;
        ctx.fillStyle = '#00ff8888';
        ctx.beginPath();
        ctx.arc(pos.x, pos.y, r, 0, Math.PI * 2);
        ctx.fill();
        ctx.font = '700 10px "JetBrains Mono", monospace';
        ctx.fillStyle = '#000';
        ctx.textAlign = 'center';
        ctx.fillText(NOTES[noteIndex], pos.x, pos.y + 3.5);
      });
    }
  }

  // ===== HIGHLIGHT GROUPS (triads/dyads) overlay pass =====
  if (state.highlightGroups.length > 0) {
    // Helper: get pixel position for a note
    function getNotePos(vi, f) {
      if (f === 0) {
        if (vert) return { x: getStringCoord(vi), y: fbY1 - FB.nutWidth / 2 };
        const nutX2 = flipH ? (w - FB.paddingRight) : FB.paddingLeft;
        return { x: flipH ? nutX2 + FB.nutWidth/2 : nutX2 - FB.nutWidth/2, y: getStringCoord(vi) };
      }
      const midFret = (fretPositions[f-1] + fretPositions[f]) / 2;
      return getNoteXY(midFret, vi);
    }

    // Compute all voicings for the active highlight group
    // Only recompute when group changes (cached)
    const grp = state.highlightGroups[state.highlightGroups.length - 1]; // use last selected
    const cacheKey = grp.key + '_' + state.tuning + '_' + state.numFrets;
    if (state._voicingCacheKey !== cacheKey) {
      const notePositions = {};
      grp.notes.forEach(n => { notePositions[n] = []; });
      for (let vi = 0; vi < numStrings; vi++) {
        const si = stringOrder[vi];
        for (let f = 0; f <= state.numFrets; f++) {
          const noteIndex = (tuningMidi[si] + f) % 12;
          if (grp.notes.includes(noteIndex)) {
            notePositions[noteIndex].push({ vi, f });
          }
        }
      }
      const noteKeys = grp.notes;
      const voicings = [];
      function findVoicings(depth, current, usedStrings) {
        if (depth === noteKeys.length) {
          voicings.push([...current]);
          return;
        }
        const positions = notePositions[noteKeys[depth]];
        for (const p of positions) {
          if (usedStrings.has(p.vi)) continue;
          const fretted = [...current, p].filter(c => c.f > 0).map(c => c.f);
          const span = fretted.length > 0 ? (Math.max(...fretted) - Math.min(...fretted)) : 0;
          if (span <= 4) {
            usedStrings.add(p.vi);
            current.push(p);
            findVoicings(depth + 1, current, usedStrings);
            current.pop();
            usedStrings.delete(p.vi);
          }
        }
      }
      findVoicings(0, [], new Set());
      // Sort voicings by lowest fret position for logical ordering
      voicings.sort((a, b) => {
        const aMin = Math.min(...a.map(v => v.f));
        const bMin = Math.min(...b.map(v => v.f));
        return aMin - bMin;
      });
      state.cachedVoicings = voicings;
      state._voicingCacheKey = cacheKey;
      state.voicingIndex = 0;
    }

    const allVoicings = state.cachedVoicings;
    const totalVoicings = allVoicings.length;

    if (totalVoicings > 0) {
      // Clamp index
      if (state.voicingIndex >= totalVoicings) state.voicingIndex = 0;
      if (state.voicingIndex < 0) state.voicingIndex = totalVoicings - 1;

      const voicing = allVoicings[state.voicingIndex];

      // Dim everything
      ctx.fillStyle = 'rgba(10, 10, 15, 0.78)';
      ctx.fillRect(0, 0, w, h);

      // Redraw fret numbers + string labels dimmed
      ctx.font = '500 11px "JetBrains Mono", monospace';
      ctx.fillStyle = '#555570';
      for (let f = 1; f <= state.numFrets; f++) {
        const midFret = (fretPositions[f-1] + fretPositions[f]) / 2;
        const fc = getFretCoord(midFret);
        if (vert) { ctx.textAlign = 'right'; ctx.fillText(f, fbX1 - 8, fc + 4); }
        else { ctx.textAlign = 'center'; ctx.fillText(f, fc, fbY2 + 20); }
      }
      ctx.font = '600 12px "JetBrains Mono", monospace';
      for (let vi = 0; vi < numStrings; vi++) {
        const si = stringOrder[vi];
        const sc = getStringCoord(vi);
        ctx.fillStyle = '#8888aa';
        if (vert) { ctx.textAlign = 'center'; ctx.fillText(tuningLabels[si], sc, fbY1 - FB.nutWidth - 6); }
        else { ctx.textAlign = flipH ? 'left' : 'right'; ctx.fillText(tuningLabels[si], flipH ? (w-FB.paddingRight+14) : (FB.paddingLeft-14), sc+4); }
      }

      // Highlight the fret range for this voicing
      const fretted = voicing.filter(v => v.f > 0).map(v => v.f);
      if (fretted.length > 0) {
        const loFret = Math.min(...fretted);
        const hiFret = Math.max(...fretted);
        const x1 = getFretCoord(fretPositions[loFret - 1]);
        const x2 = getFretCoord(fretPositions[hiFret]);
        ctx.fillStyle = 'rgba(108, 92, 231, 0.08)';
        if (vert) {
          ctx.fillRect(fbX1, Math.min(x1, x2), fbX2 - fbX1, Math.abs(x2 - x1));
        } else {
          ctx.fillRect(Math.min(x1, x2), fbY1, Math.abs(x2 - x1), fbY2 - fbY1);
        }
      }

      // Draw the voicing shape
      const vColor = '#00e5ff';
      const sorted = [...voicing].sort((a, b) => a.vi - b.vi);
      const points = sorted.map(v => getNotePos(v.vi, v.f));

      // Filled polygon
      if (points.length >= 3) {
        ctx.fillStyle = vColor + '18';
        ctx.strokeStyle = vColor + '40';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(points[0].x, points[0].y);
        for (let i = 1; i < points.length; i++) ctx.lineTo(points[i].x, points[i].y);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
      }

      // Connecting lines
      ctx.strokeStyle = vColor + '70';
      ctx.lineWidth = 2.5;
      ctx.setLineDash([6, 4]);
      for (let i = 0; i < sorted.length; i++) {
        const next = (i + 1) % sorted.length;
        const p1 = getNotePos(sorted[i].vi, sorted[i].f);
        const p2 = getNotePos(sorted[next].vi, sorted[next].f);
        ctx.beginPath();
        ctx.moveTo(p1.x, p1.y);
        ctx.lineTo(p2.x, p2.y);
        ctx.stroke();
      }
      ctx.setLineDash([]);

      // Draw note circles - big and bold
      sorted.forEach((v, ni) => {
        const pos = getNotePos(v.vi, v.f);
        const noteIndex = (tuningMidi[stringOrder[v.vi]] + v.f) % 12;
        const isRoot = getInterval(state.rootNote, noteIndex) === 0;
        const r = FB.noteRadius + 3;

        // Glow
        ctx.shadowColor = vColor;
        ctx.shadowBlur = 18;

        // Outer ring
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2.5;
        ctx.beginPath();
        ctx.arc(pos.x, pos.y, r + 3, 0, Math.PI * 2);
        ctx.stroke();

        // Fill
        ctx.fillStyle = isRoot ? '#6c5ce7' : vColor;
        if (isRoot) {
          const dr = r + 1;
          ctx.beginPath();
          ctx.moveTo(pos.x, pos.y-dr); ctx.lineTo(pos.x+dr, pos.y);
          ctx.lineTo(pos.x, pos.y+dr); ctx.lineTo(pos.x-dr, pos.y);
          ctx.closePath(); ctx.fill();
          ctx.strokeStyle = '#fff'; ctx.lineWidth = 2.5; ctx.stroke();
        } else {
          ctx.beginPath();
          ctx.arc(pos.x, pos.y, r, 0, Math.PI * 2);
          ctx.fill();
        }
        ctx.shadowBlur = 0;

        // Note name label
        ctx.font = '800 12px "JetBrains Mono", monospace';
        ctx.fillStyle = '#000';
        ctx.textAlign = 'center';
        ctx.fillText(NOTES[noteIndex], pos.x, pos.y + 4);

        // Interval role below note (Root / interval name)
        const ivRole = getInterval(state.rootNote, noteIndex);
        const roleLabel = ivRole === 0 ? 'Root' : INTERVAL_NAMES[ivRole];
        ctx.font = '600 9px "JetBrains Mono", monospace';
        ctx.fillStyle = ivRole === 0 ? '#a855f7' : '#00e5ff';
        ctx.fillText(roleLabel, pos.x, pos.y + r + 13);
        // Fret label
        ctx.font = '500 8px "Inter", sans-serif';
        ctx.fillStyle = '#66669980';
        ctx.fillText('fret ' + v.f, pos.x, pos.y + r + 23);
      });

      // Draw voicing navigator on canvas
      const navY = vert ? h - 40 : fbY2 + 50;
      const navX = w / 2;

      // Build note names for the current voicing
      const vNoteNames = [...voicing].sort((a,b) => a.vi - b.vi).map(v => {
        const ni = (tuningMidi[stringOrder[v.vi]] + v.f) % 12;
        return NOTES[ni];
      }).filter((n,i,a) => a.indexOf(n) === i).join(' Â· ');

      ctx.font = '700 14px "Inter", sans-serif';
      ctx.fillStyle = '#e8e8f0';
      ctx.textAlign = 'center';
      ctx.fillText(grp.label, navX, navY);

      ctx.font = '600 12px "JetBrains Mono", monospace';
      ctx.fillStyle = '#00e5ff';
      ctx.fillText(vNoteNames, navX, navY + 17);

      ctx.font = '400 10px "Inter", sans-serif';
      ctx.fillStyle = '#8888aa';
      const fInfo = voicing.map(v => 'F' + v.f).join(' ');
      ctx.fillText('Voicing ' + (state.voicingIndex + 1) + '/' + totalVoicings + '  [ ' + fInfo + ' ]  \u25C0 \u25B6 arrows  Â·  ESC close', navX, navY + 32);
    } else {
      // No voicings found
      ctx.fillStyle = 'rgba(10, 10, 15, 0.78)';
      ctx.fillRect(0, 0, w, h);
      ctx.font = '600 16px "Inter", sans-serif';
      ctx.fillStyle = '#e84393';
      ctx.textAlign = 'center';
      ctx.fillText('No playable voicings found for ' + grp.label, w / 2, h / 2);
      ctx.font = '400 12px "Inter", sans-serif';
      ctx.fillStyle = '#8888aa';
      ctx.fillText('Press ESC to close', w / 2, h / 2 + 24);
    }
  }

  ctx.globalAlpha = 1;
  updateLegend();
}

// ===== LEGEND =====
function updateLegend() {
  const legendEl = document.getElementById('legendItems');
  const infoBar = document.getElementById('infoBar');
  const hasScales = state.selectedScales.length > 0;
  const hasChords = state.selectedChords.length > 0;

  if (!hasScales && !hasChords) {
    legendEl.innerHTML = `<div class="legend-item"><div class="legend-swatch root" style="background:var(--accent);"></div> All ${NOTES[state.rootNote]} notes on fretboard</div>`;
    infoBar.innerHTML = '<div class="info-item" style="color:var(--text-secondary);">Showing every <strong>' + NOTES[state.rootNote] + '</strong> position. Hit <strong>Play</strong> to cycle through all notes, or select a scale/chord to explore further.</div>';
    return;
  }

  let html = '';
  html += `<div class="legend-item"><div class="legend-swatch root" style="background:var(--accent);"></div> Root (${NOTES[state.rootNote]})</div>`;

  // Scale colors
  state.selectedScales.forEach((name, i) => {
    const color = SCALE_COLORS[i % SCALE_COLORS.length];
    html += `<div class="legend-item"><div class="legend-swatch" style="background:${color};"></div> ${name}</div>`;
  });

  // Chord colors
  state.selectedChords.forEach((name, i) => {
    const color = CHORD_COLORS[i % CHORD_COLORS.length];
    html += `<div class="legend-item"><div class="legend-swatch chord-ring" style="border-color:${color};"></div> ${NOTES[state.rootNote]} ${name}</div>`;
  });

  // Common indicators
  if (state.selectedScales.length > 1 || (hasScales && hasChords) || state.selectedChords.length > 1) {
    html += `<div class="legend-item"><div class="legend-swatch common"></div> Common Notes</div>`;
  }

  legendEl.innerHTML = html;

  // Info bar
  let infoHtml = '';
  state.selectedScales.forEach((name, i) => {
    const scale = SCALES[name];
    const notes = scale.intervals.map(iv => NOTES[(state.rootNote + iv) % 12]).join(' ');
    const color = SCALE_COLORS[i % SCALE_COLORS.length];
    infoHtml += `<div class="info-item"><strong style="color:${color}">${NOTES[state.rootNote]} ${name}:</strong> ${notes}</div>`;
  });

  state.selectedChords.forEach((name, i) => {
    const chord = CHORDS[name];
    const notes = chord.intervals.map(iv => NOTES[(state.rootNote + iv) % 12]).join(' ');
    const color = CHORD_COLORS[i % CHORD_COLORS.length];
    infoHtml += `<div class="info-item"><strong style="color:${color}">${NOTES[state.rootNote]} ${name}:</strong> ${notes} <span style="color:var(--text-muted);">(${chord.formula})</span></div>`;
  });

  // Find common notes across all selected items
  const allSets = [];
  state.selectedScales.forEach(name => {
    allSets.push(new Set(SCALES[name].intervals.map(iv => (state.rootNote + iv) % 12)));
  });
  state.selectedChords.forEach(name => {
    allSets.push(new Set(CHORDS[name].intervals.map(iv => (state.rootNote + iv) % 12)));
  });

  if (allSets.length > 1) {
    let common = new Set(allSets[0]);
    for (let i = 1; i < allSets.length; i++) {
      common = new Set([...common].filter(n => allSets[i].has(n)));
    }
    if (common.size > 0) {
      const sorted = [...common].sort((a,b) => ((a-state.rootNote+12)%12) - ((b-state.rootNote+12)%12));
      infoHtml += `<div class="info-item"><strong style="color:#ffd700">Common across all:</strong> ${sorted.map(n=>NOTES[n]).join(' ')} (${common.size} notes)</div>`;
    }
  }

  // If we have both scales and chords, show which chord tones are in each scale
  if (hasScales && hasChords) {
    state.selectedChords.forEach((chordName, ci) => {
      const chordNotes = new Set(CHORDS[chordName].intervals.map(iv => (state.rootNote + iv) % 12));
      state.selectedScales.forEach((scaleName, si) => {
        const scaleNotes = new Set(SCALES[scaleName].intervals.map(iv => (state.rootNote + iv) % 12));
        const overlap = [...chordNotes].filter(n => scaleNotes.has(n));
        const missing = [...chordNotes].filter(n => !scaleNotes.has(n));
        const sColor = SCALE_COLORS[si % SCALE_COLORS.length];
        const cColor = CHORD_COLORS[ci % CHORD_COLORS.length];
        if (missing.length === 0) {
          infoHtml += `<div class="info-item"><strong style="color:#81C784">&#10003;</strong> <strong style="color:${cColor}">${NOTES[state.rootNote]} ${chordName}</strong> fits entirely within <strong style="color:${sColor}">${scaleName}</strong></div>`;
        } else {
          infoHtml += `<div class="info-item"><strong style="color:${cColor}">${NOTES[state.rootNote]} ${chordName}</strong> in <strong style="color:${sColor}">${scaleName}</strong>: ${overlap.length}/${chordNotes.size} tones match, outside: ${missing.map(n=>NOTES[n]).join(' ')}</div>`;
        }
      });
    });
  }

  // Per-note overlap breakdown (when 2+ scales/chords selected)
  const totalSelections = state.selectedScales.length + state.selectedChords.length;
  if (totalSelections >= 2 && (state.selectedScales.length + state.selectedChords.length >= 2)) {
    // Build a map: noteIndex -> [{name, color, type}]
    const noteMap = {};
    state.selectedScales.forEach((name, i) => {
      const color = SCALE_COLORS[i % SCALE_COLORS.length];
      SCALES[name].intervals.forEach(iv => {
        const n = (state.rootNote + iv) % 12;
        if (!noteMap[n]) noteMap[n] = [];
        noteMap[n].push({ name, color, type: 'scale' });
      });
    });
    state.selectedChords.forEach((name, i) => {
      const color = CHORD_COLORS[i % CHORD_COLORS.length];
      CHORDS[name].intervals.forEach(iv => {
        const n = (state.rootNote + iv) % 12;
        if (!noteMap[n]) noteMap[n] = [];
        noteMap[n].push({ name: NOTES[state.rootNote]+' '+name, color, type: 'chord' });
      });
    });

    // Sort notes by interval from root, filter to those in 2+ selections
    const overlapNotes = Object.entries(noteMap)
      .filter(([_, hits]) => hits.length >= 2)
      .sort((a,b) => ((a[0]-state.rootNote+12)%12) - ((b[0]-state.rootNote+12)%12));

    if (overlapNotes.length > 0) {
      infoHtml += '<div style="width:100%; margin-top:8px; padding-top:8px; border-top:1px solid var(--border);">';
      infoHtml += '<div style="font-size:0.72em; font-weight:700; text-transform:uppercase; letter-spacing:1.5px; color:var(--text-muted); margin-bottom:6px;">Note Overlap Breakdown</div>';
      infoHtml += '<div style="display:flex; flex-wrap:wrap; gap:8px;">';
      overlapNotes.forEach(([noteIdx, hits]) => {
        const noteName = NOTES[noteIdx];
        const count = hits.length;
        const badgeColor = count >= 4 ? '#ff4757' : count >= 3 ? '#ffa502' : '#ffd700';
        const memberNames = hits.map(h =>
          `<span style="color:${h.color};">${h.name}</span>`
        ).join(', ');
        infoHtml += `<div style="background:var(--bg-tertiary); border:1px solid var(--border); border-radius:8px; padding:6px 10px; font-size:0.8em;">`;
        infoHtml += `<span style="display:inline-block; background:${badgeColor}; color:#000; font-weight:700; border-radius:4px; padding:1px 6px; margin-right:5px; font-size:0.85em;">${noteName} x${count}</span> `;
        infoHtml += memberNames;
        infoHtml += `</div>`;
      });
      infoHtml += '</div></div>';
    }
  }

  // Triad & Dyad breakdown for selected chords (advanced mode only, hidden by default)
  if (false && hasChords && !state.simpleMode) {
    infoHtml += '<div style="width:100%; margin-top:8px; padding-top:8px; border-top:1px solid var(--border);">';
    infoHtml += '<div style="font-size:0.72em; font-weight:700; text-transform:uppercase; letter-spacing:1.5px; color:var(--text-muted); margin-bottom:8px;">Chord Anatomy: Triads &amp; Dyads</div>';

    let hlIdx = 0; // running index for highlight colors

    state.selectedChords.forEach((chordName, ci) => {
      const chord = CHORDS[chordName];
      const color = CHORD_COLORS[ci % CHORD_COLORS.length];
      const chordNotes = chord.intervals.map(iv => (state.rootNote + iv) % 12);

      infoHtml += `<div style="margin-bottom:10px;">`;
      infoHtml += `<div style="font-size:0.82em; font-weight:600; color:${color}; margin-bottom:4px;">${NOTES[state.rootNote]} ${chordName} (${chordNotes.map(n=>NOTES[n]).join(' ')})</div>`;

      // Find triads
      if (chordNotes.length >= 3) {
        const triads = [];
        for (let a = 0; a < chordNotes.length; a++) {
          for (let b = a+1; b < chordNotes.length; b++) {
            for (let c = b+1; c < chordNotes.length; c++) {
              const trio = [chordNotes[a], chordNotes[b], chordNotes[c]];
              const match = identifyTriad(trio);
              if (match) { match.noteIndices = trio; triads.push(match); }
            }
          }
        }
        if (triads.length > 0) {
          infoHtml += `<div style="font-size:0.75em; color:var(--text-muted); margin-bottom:3px;">TRIADS <span style="font-weight:400;">(click to highlight on fretboard)</span>:</div>`;
          infoHtml += '<div style="display:flex; flex-wrap:wrap; gap:5px; margin-bottom:6px;">';
          triads.forEach(t => {
            const hColor = HIGHLIGHT_COLORS[hlIdx % HIGHLIGHT_COLORS.length];
            const groupKey = 'triad-' + t.noteIndices.join('-');
            const isActive = state.highlightGroups.some(g => g.key === groupKey);
            const activeStyle = isActive
              ? `background:${hColor}30; border-color:${hColor}; color:${hColor}; box-shadow:0 2px 8px ${hColor}40;`
              : '';
            infoHtml += `<span class="group-tag ${isActive?'active':''}" style="${activeStyle}" onclick="toggleHighlightGroup('${groupKey}',[${t.noteIndices}],'${hColor}','${t.root} ${t.type}','triad')" title="Notes: ${t.notes}">`
              + `<span style="display:inline-block;width:8px;height:8px;border-radius:50%;background:${hColor};margin-right:4px;vertical-align:middle;"></span>`
              + `${t.root} ${t.type} <span style="opacity:0.85;font-family:'JetBrains Mono',monospace;font-size:0.88em;">(${t.notes})</span></span>`;
            hlIdx++;
          });
          infoHtml += '</div>';
        }
      }

      // Find dyads
      if (chordNotes.length >= 2) {
        const dyads = [];
        for (let a = 0; a < chordNotes.length; a++) {
          for (let b = a+1; b < chordNotes.length; b++) {
            const iv = (chordNotes[b] - chordNotes[a] + 12) % 12;
            dyads.push({
              noteIndices: [chordNotes[a], chordNotes[b]],
              notes: NOTES[chordNotes[a]] + '-' + NOTES[chordNotes[b]],
              interval: DYAD_NAMES[iv] || INTERVAL_NAMES[iv],
            });
          }
        }
        infoHtml += `<div style="font-size:0.75em; color:var(--text-muted); margin-bottom:3px;">DYADS <span style="font-weight:400;">(click to highlight)</span>:</div>`;
        infoHtml += '<div style="display:flex; flex-wrap:wrap; gap:5px;">';
        dyads.forEach(d => {
          const hColor = HIGHLIGHT_COLORS[hlIdx % HIGHLIGHT_COLORS.length];
          const groupKey = 'dyad-' + d.noteIndices.join('-');
          const isActive = state.highlightGroups.some(g => g.key === groupKey);
          const activeStyle = isActive
            ? `background:${hColor}30; border-color:${hColor}; color:${hColor}; box-shadow:0 2px 8px ${hColor}40;`
            : '';
          infoHtml += `<span class="group-tag ${isActive?'active':''}" style="${activeStyle}" onclick="toggleHighlightGroup('${groupKey}',[${d.noteIndices}],'${hColor}','${d.notes}','dyad')">`
            + `<span style="display:inline-block;width:8px;height:8px;border-radius:50%;background:${hColor};margin-right:4px;vertical-align:middle;"></span>`
            + `${d.notes} <span style="opacity:0.7; font-weight:600;">${d.interval}</span></span>`;
          hlIdx++;
        });
        infoHtml += '</div>';
      }

      infoHtml += '</div>';
    });
    infoHtml += '</div>';
  }

  infoBar.innerHTML = infoHtml;
}

// Known triad interval patterns (semitones from root)
const TRIAD_TYPES = {
  'Major':     [0,4,7],
  'Minor':     [0,3,7],
  'Diminished':[0,3,6],
  'Augmented': [0,4,8],
  'sus2':      [0,2,7],
  'sus4':      [0,5,7],
};

// Dyad interval names (more musical than generic interval names)
const DYAD_NAMES = {
  1: 'Minor 2nd',
  2: 'Major 2nd',
  3: 'Minor 3rd',
  4: 'Major 3rd',
  5: 'Perfect 4th',
  6: 'Tritone',
  7: 'Perfect 5th',
  8: 'Minor 6th',
  9: 'Major 6th',
  10: 'Minor 7th',
  11: 'Major 7th',
};

function identifyTriad(threeNotes) {
  // Try each note as the root and check if intervals match a known triad
  for (let r = 0; r < 3; r++) {
    const root = threeNotes[r];
    const others = threeNotes.filter((_, i) => i !== r);
    const intervals = [0, ...others.map(n => (n - root + 12) % 12)].sort((a,b) => a - b);

    for (const [type, pattern] of Object.entries(TRIAD_TYPES)) {
      if (intervals.length === pattern.length &&
          intervals.every((iv, i) => iv === pattern[i])) {
        return {
          root: NOTES[root],
          type: type,
          notes: [root, ...others].map(n => NOTES[n]).join(' '),
        };
      }
    }
  }
  return null;
}

// ===== UI BUILDERS =====
function buildRootNotes() {
  const container = document.getElementById('rootNotes');
  container.innerHTML = '';
  NOTES.forEach((note, i) => {
    const btn = document.createElement('button');
    btn.className = 'note-btn' + (i === state.rootNote ? ' active' : '');
    btn.textContent = note;
    btn.onclick = () => { state.rootNote = i; state.scalePositionCache = {}; state.scalePositionIndex = 0; buildRootNotes(); renderScalePositionNav(); draw(); };
    container.appendChild(btn);
  });
}

function buildScaleList() {
  const container = document.getElementById('scaleList');
  container.innerHTML = '';
  const categories = {};
  for (const [name, info] of Object.entries(SCALES)) {
    if (state.simpleMode && !SIMPLE_SCALES.has(name)) continue;
    if (state.simpleMode && !SIMPLE_SCALE_CAT_NAMES[info.category]) continue;
    if (!categories[info.category]) categories[info.category] = [];
    categories[info.category].push(name);
  }
  for (const [cat, scales] of Object.entries(categories)) {
    const catDiv = document.createElement('div');
    const title = document.createElement('div');
    title.className = 'scale-category-title';
    title.textContent = state.simpleMode ? (SIMPLE_SCALE_CAT_NAMES[cat] || cat) : cat;
    catDiv.appendChild(title);
    const grid = document.createElement('div');
    grid.className = 'scale-grid';
    scales.forEach(name => {
      const btn = document.createElement('button');
      btn.className = 'scale-btn';
      const idx = state.selectedScales.indexOf(name);
      if (idx !== -1) {
        const color = SCALE_COLORS[idx % SCALE_COLORS.length];
        btn.classList.add('active');
        btn.style.background = color + '25';
        btn.style.borderColor = color;
        btn.style.color = color;
      }
      const dot = document.createElement('span');
      dot.className = 'color-dot';
      if (idx !== -1) dot.style.background = SCALE_COLORS[idx % SCALE_COLORS.length];
      btn.appendChild(dot);
      btn.appendChild(document.createTextNode(name));
      btn.onclick = () => {
        const ei = state.selectedScales.indexOf(name);
        if (ei !== -1) { state.selectedScales.splice(ei, 1); }
        else {
          if (state.selectedScales.length >= SCALE_COLORS.length) state.selectedScales.shift();
          state.selectedScales.push(name);
        }
        state.scalePositionIndex = 0;
        state.scalePositionCache = {};
        updateCounts(); buildScaleList(); draw();
      };
      grid.appendChild(btn);
    });
    catDiv.appendChild(grid);
    container.appendChild(catDiv);
  }
  // Position navigator (appears below scale buttons when a scale is active)
  let nav = document.getElementById('scalePositionNav');
  if (!nav) {
    nav = document.createElement('div');
    nav.id = 'scalePositionNav';
    container.parentNode.appendChild(nav);
  }
  renderScalePositionNav();
}

function buildChordList() {
  const container = document.getElementById('chordList');
  container.innerHTML = '';
  const categories = {};
  for (const [name, info] of Object.entries(CHORDS)) {
    if (state.simpleMode && !SIMPLE_CHORDS.has(name)) continue;
    if (state.simpleMode && !SIMPLE_CHORD_CAT_NAMES[info.category]) continue;
    if (!categories[info.category]) categories[info.category] = [];
    categories[info.category].push(name);
  }
  for (const [cat, chords] of Object.entries(categories)) {
    const catDiv = document.createElement('div');
    const title = document.createElement('div');
    title.className = 'chord-category-title';
    title.textContent = state.simpleMode ? (SIMPLE_CHORD_CAT_NAMES[cat] || cat) : cat;
    catDiv.appendChild(title);
    const grid = document.createElement('div');
    grid.className = 'chord-grid';
    chords.forEach(name => {
      const btn = document.createElement('button');
      btn.className = 'chord-btn';
      const idx = state.selectedChords.indexOf(name);
      if (idx !== -1) {
        const color = CHORD_COLORS[idx % CHORD_COLORS.length];
        btn.classList.add('active');
        btn.style.background = color + '25';
        btn.style.borderColor = color;
        btn.style.color = color;
      }
      const dot = document.createElement('span');
      dot.className = 'color-dot';
      if (idx !== -1) dot.style.background = CHORD_COLORS[idx % CHORD_COLORS.length];
      btn.appendChild(dot);

      // Show chord name with root
      const label = document.createTextNode(NOTES[state.rootNote] + ' ' + name);
      btn.appendChild(label);

      // Formula tooltip
      btn.title = CHORDS[name].formula;

      btn.onclick = () => {
        const ei = state.selectedChords.indexOf(name);
        if (ei !== -1) { state.selectedChords.splice(ei, 1); }
        else {
          if (state.selectedChords.length >= CHORD_COLORS.length) state.selectedChords.shift();
          state.selectedChords.push(name);
        }
        state.highlightGroups = []; // clear triad/dyad highlights when chords change
        updateCounts(); buildChordList(); renderChordDiagrams(); draw();
      };
      grid.appendChild(btn);
    });
    catDiv.appendChild(grid);
    container.appendChild(catDiv);
  }
}

function updateCounts() {
  const sc = document.getElementById('scaleCount');
  const cc = document.getElementById('chordCount');
  sc.textContent = state.selectedScales.length > 0 ? `(${state.selectedScales.length})` : '';
  cc.textContent = state.selectedChords.length > 0 ? `(${state.selectedChords.length})` : '';
}

function switchTab(tab) {
  if (tab !== 'tab' && state.tabPlaying) tabStop();
  state.activeTab = tab;
  document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
  document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
  if (tab === 'scales') {
    document.querySelector('.tab-btn.scales-tab').classList.add('active');
    document.getElementById('tab-scales').classList.add('active');
  } else if (tab === 'chords') {
    document.querySelector('.tab-btn.chord-tab').classList.add('active');
    document.getElementById('tab-chords').classList.add('active');
  } else if (tab === 'tab') {
    document.querySelector('.tab-btn.tab-player-tab').classList.add('active');
    document.getElementById('tab-tab').classList.add('active');
  }
}

// ===== TOOLBAR =====
function toggleVertical() {
  state.vertical = !state.vertical;
  document.getElementById('rotateBtn').classList.toggle('active', state.vertical);
  triggerNoteAnim();
}
function toggleFlipH() {
  state.flipH = !state.flipH;
  document.getElementById('flipH').classList.toggle('active', state.flipH);
  draw();
}
function toggleFlipV() {
  state.flipV = !state.flipV;
  document.getElementById('flipV').classList.toggle('active', state.flipV);
  draw();
}
function setLabelMode(mode) {
  state.labelMode = mode;
  document.getElementById('labelNotes').classList.toggle('active', mode === 'notes');
  document.getElementById('labelIntervals').classList.toggle('active', mode === 'intervals');
  document.getElementById('labelDegrees').classList.toggle('active', mode === 'degrees');
  draw();
}
function changeTuning() {
  state.tuning = document.getElementById('tuningSelect').value;
  clearChordDiagramCache();
  renderChordDiagrams();
  draw();
}
function setFrets(n) {
  state.numFrets = n;
  document.querySelectorAll('.fret-btn').forEach(b => b.classList.toggle('active', parseInt(b.textContent) === n));
  clearChordDiagramCache();
  renderChordDiagrams();
  draw();
}
function clearAll() {
  state.selectedScales = [];
  state.selectedChords = [];
  state.highlightGroups = [];
  if (state.tabPlaying) tabStop();
  state.tabCurrentBeat = -1;
  updateCounts();
  buildScaleList();
  buildChordList();
  clearChordDiagramCache();
  renderChordDiagrams();
  draw();
}

function toggleHighlightGroup(key, notes, color, label, type) {
  const idx = state.highlightGroups.findIndex(g => g.key === key);
  if (idx !== -1) {
    state.highlightGroups.splice(idx, 1);
  } else {
    // Only allow one group at a time for clean voicing browsing
    state.highlightGroups = [{ key, notes, color, label, type }];
  }
  state._voicingCacheKey = null; // force recompute
  state.voicingIndex = 0;
  draw();
}

// ===== SIMPLE / ADVANCED MODE =====
function initMode() {
  const saved = localStorage.getItem('guitarMode');
  state.simpleMode = saved !== 'advanced'; // default = simple
  applyMode();
}

function toggleMode() {
  state.simpleMode = !state.simpleMode;
  localStorage.setItem('guitarMode', state.simpleMode ? 'simple' : 'advanced');
  applyMode();
  // Remove any selected scales/chords that aren't in simple whitelist
  if (state.simpleMode) {
    state.selectedScales = state.selectedScales.filter(s => SIMPLE_SCALES.has(s));
    state.selectedChords = state.selectedChords.filter(c => SIMPLE_CHORDS.has(c));
    // Revert exotic tunings
    const sel = document.getElementById('tuningSelect');
    if (!SIMPLE_TUNINGS.has(sel.value)) {
      sel.value = 'standard';
      state.tuning = 'standard';
    }
    // Reset label mode to notes
    if (state.labelMode !== 'notes') setLabelMode('notes');
    // Stop vertical mode
    if (state.vertical) toggleVertical();
    updateCounts();
  }
  buildScaleList();
  buildChordList();
  draw();
}

function applyMode() {
  document.body.classList.toggle('simple-mode', state.simpleMode);
  const pill = document.getElementById('modePill');
  if (state.simpleMode) {
    pill.textContent = 'âš™ Advanced';
    pill.classList.remove('adv');
  } else {
    pill.textContent = 'âœ¦ Simple';
    pill.classList.add('adv');
  }
  // Show/hide advanced tuning options
  const sel = document.getElementById('tuningSelect');
  sel.querySelectorAll('option[data-advanced]').forEach(opt => {
    opt.hidden = state.simpleMode;
    opt.disabled = state.simpleMode;
  });
}

// ===== CHORD SHAPE DIAGRAMS =====
// Compute 5 CAGED-style scale positions across the neck.
// Anchors each position to where the root note first appears on each string
// (B, G, D, A, low E) â€” one position per CAGED shape.
function computeScalePositions(scaleIntervals, rootNote, tuningMidi, numFrets) {
  const scaleNoteSet = new Set(scaleIntervals.map(iv => (rootNote + iv) % 12));
  const allNotes = [];
  for (let vi = 0; vi < 6; vi++) {
    for (let f = 0; f <= numFrets; f++) {
      if (scaleNoteSet.has((tuningMidi[vi] + f) % 12)) allNotes.push({ vi, f });
    }
  }
  // Find the first fret (within one octave) where the root appears on each of the 5 strings
  // (B=4, G=3, D=2, A=1, lowE=0) â€” corresponds loosely to C, G, E, A, D CAGED shapes
  const anchorStrings = [4, 3, 2, 1, 0];
  const anchors = [];
  for (const vi of anchorStrings) {
    for (let f = 0; f <= 12; f++) {
      if ((tuningMidi[vi] + f) % 12 === rootNote) { anchors.push(f); break; }
    }
  }
  anchors.sort((a, b) => a - b);
  const unique = [...new Set(anchors)];
  return unique.slice(0, 5).map(anchor => {
    const start = Math.max(0, anchor - 1);
    const end   = Math.min(numFrets, anchor + 4);
    return allNotes.filter(p => p.f >= start && p.f <= end);
  }).filter(pos => pos.length > 0);
}

// Generates real guitar chord voicings using consecutive strings (4-6) with note doubling.
// This produces standard shapes like open D (xx0232), barre A-shape, barre E-shape etc.
function computeVoicings(noteIndices, tuningMidi, stringOrder, numFrets, maxSpan) {
  maxSpan = maxSpan || 4;
  const numStrings = stringOrder.length; // 6
  const chordNoteSet = new Set(noteIndices);
  const allVoicings = [];

  // Try groups of 4, 5, or 6 consecutive strings
  for (let groupSize = 6; groupSize >= 4; groupSize--) {
    for (let startVI = 0; startVI <= numStrings - groupSize; startVI++) {
      // Build chord-tone fret positions available on each string in this group
      const stringOpts = [];
      let groupValid = true;
      for (let g = 0; g < groupSize; g++) {
        const vi = startVI + g;
        const si = stringOrder[vi];
        const opts = [];
        for (let f = 0; f <= numFrets; f++) {
          if (chordNoteSet.has((tuningMidi[si] + f) % 12)) opts.push({ vi, f });
        }
        if (!opts.length) { groupValid = false; break; }
        stringOpts.push(opts);
      }
      if (!groupValid) continue;

      // Use a named const (not a function declaration) to avoid hoisting in loops
      const tryNext = (g, current, minF, maxF) => {
        if (g === groupSize) {
          const covered = new Set(current.map(p => (tuningMidi[stringOrder[p.vi]] + p.f) % 12));
          if (noteIndices.some(n => !covered.has(n))) return;
          allVoicings.push([...current]);
          return;
        }
        for (const p of stringOpts[g]) {
          let nMin = minF, nMax = maxF;
          if (p.f > 0) {
            nMin = minF < 0 ? p.f : Math.min(minF, p.f);
            nMax = maxF < 0 ? p.f : Math.max(maxF, p.f);
            if (nMax - nMin > maxSpan) continue;
          }
          current.push(p);
          tryNext(g + 1, current, nMin, nMax);
          current.pop();
        }
      };
      tryNext(0, [], -1, -1);
    }
  }

  // Deduplicate and sort by lowest fretted note
  const seen = new Set();
  return allVoicings
    .filter(v => {
      const key = v.map(p => p.vi + ':' + p.f).sort().join(',');
      return seen.has(key) ? false : (seen.add(key), true);
    })
    .sort((a, b) => {
      const aMin = Math.min(...a.map(p => p.f));
      const bMin = Math.min(...b.map(p => p.f));
      return aMin - bMin;
    });
}

function computeCAGEDVoicings(noteIndices, tuningMidi, stringOrder, numFrets) {
  const all = computeVoicings(noteIndices, tuningMidi, stringOrder, numFrets, 4);
  if (!all.length) return all;
  const rootNote = noteIndices[0];

  // Require root in bass: the lowest string of the voicing must play the root.
  // This selects standard shapes (open D, open C, barre chords) and rejects inversions.
  const rootBass = all.filter(v => {
    const lowestVi = Math.min(...v.map(p => p.vi));
    const bass = v.find(p => p.vi === lowestVi);
    return (tuningMidi[stringOrder[lowestVi]] + bass.f) % 12 === rootNote;
  });
  // Fall back to all voicings if root-in-bass filter leaves fewer than 2
  const candidates = rootBass.length >= 2 ? rootBass : all;

  // Reject unplayable shapes: open strings mixed with high frets are not real chord shapes.
  // A voicing with open strings is only valid in first position (minFretted <= 4).
  const playable = candidates.filter(v => {
    const frettedFs = v.filter(p => p.f > 0).map(p => p.f);
    const minF = frettedFs.length ? Math.min(...frettedFs) : 0;
    const hasOpen = v.some(p => p.f === 0);
    return !hasOpen || minF <= 4;
  });
  const pool = playable.length >= 2 ? playable : candidates;

  // Group by 3-fret zone (floor(minFret/3)):
  //   zone 0 (frets 0-2): open chord shapes  (C-shape, open D, open G etc.)
  //   zone 1 (frets 3-5): A-shape barres
  //   zone 2 (frets 6-8): E/G-shape barres
  //   zone 3 (frets 9-11): higher barres
  //   zone 4 (frets 12+): repeat shapes
  // Score: prefer more strings, smaller span as tiebreaker
  const zones = new Map();
  pool.forEach(v => {
    const frettedFs = v.filter(p => p.f > 0).map(p => p.f);
    const minF = frettedFs.length ? Math.min(...frettedFs) : 0;
    const zone = Math.floor(minF / 3);
    const numOpen = v.filter(p => p.f === 0).length;
    const span = frettedFs.length > 1 ? Math.max(...frettedFs) - Math.min(...frettedFs) : 0;
    const score = v.length * 100 + numOpen * 10 - span;
    const existing = zones.get(zone);
    if (!existing || score > existing.score) zones.set(zone, { v, score, minF });
  });

  return [...zones.values()]
    .sort((a, b) => a.minF - b.minF)
    .map(z => z.v)
    .slice(0, 5);
}

function renderChordDiagrams() {
  const container = document.getElementById('chordDiagrams');
  if (!state.selectedChords.length) {
    container.innerHTML = ''; container.className = ''; return;
  }
  container.className = 'chord-diagrams-wrap';
  const tuningMidi = TUNINGS[state.tuning];
  // Chord diagrams ALWAYS use standard order (low E left) â€” like every chord book
  const diagStringOrder = [0,1,2,3,4,5];
  const strLabels = TUNING_LABELS[state.tuning]; // [low to high]

  let html = '';
  state.selectedChords.forEach((chordName, ci) => {
    const chord = CHORDS[chordName];
    const chordNoteIndices = chord.intervals.map(iv => (state.rootNote + iv) % 12);
    const color = CHORD_COLORS[ci % CHORD_COLORS.length];
    // cacheKey excludes flipV â€” diagrams are orientation-independent
    const cacheKey = chordName + '_' + state.rootNote + '_' + state.tuning;
    if (!state.chordShapeVoicings[cacheKey]) {
      state.chordShapeVoicings[cacheKey] = computeCAGEDVoicings(chordNoteIndices, tuningMidi, diagStringOrder, state.numFrets);
      state.chordShapeIndex[cacheKey] = 0;
    }
    const voicings = state.chordShapeVoicings[cacheKey];
    if (!voicings.length) return;
    const idx = Math.max(0, Math.min(state.chordShapeIndex[cacheKey] || 0, voicings.length - 1));
    const voicing = voicings[idx];
    html += `<div class="chord-diagram-card" style="border-color:${color}55;">`;
    html += `<div class="cdg-title" style="color:${color};">${NOTES[state.rootNote]} ${chordName}</div>`;
    html += buildDiagramSVG(voicing, tuningMidi, diagStringOrder, strLabels, chordNoteIndices, color);
    html += `<div class="cdg-nav">`;
    if (voicings.length > 1) {
      html += `<button onclick="shiftChordDiagram('${cacheKey}',-1)">&#9664;</button>`;
      html += `<span>${idx+1}/${Math.min(voicings.length,99)}</span>`;
      html += `<button onclick="shiftChordDiagram('${cacheKey}',1)">&#9654;</button>`;
    } else {
      html += `<span>1 voicing</span>`;
    }
    html += `</div>`;
    html += `<button onclick="strumCurrentVoicing()" style="margin-top:6px;width:100%;padding:5px 0;background:#1a1a28;border:1px solid ${color}55;border-radius:6px;color:${color};font-size:0.8em;cursor:pointer;letter-spacing:0.5px;" title="Strum this chord">&#9654; Strum</button>`;
    html += `</div>`;
  });
  container.innerHTML = html;
}

function buildDiagramSVG(voicing, tuningMidi, stringOrder, strLabels, chordNoteIndices, color) {
  const W = 116, PL = 18, PR = 8, PT = 26, fretH = 17, numFrets = 5, numStr = 6;
  const strW = (W - PL - PR) / (numStr - 1);
  const fretMap = {};
  voicing.forEach(v => { fretMap[v.vi] = v.f; });
  const frettedFrets = voicing.filter(v => v.f > 0).map(v => v.f);
  const minFret = frettedFrets.length ? Math.min(...frettedFrets) : 1;
  const fretWindow = minFret;
  const H = PT + fretH * numFrets + 14;
  let svg = `<svg width="${W}" height="${H}" viewBox="0 0 ${W} ${H}" xmlns="http://www.w3.org/2000/svg">`;

  // String labels
  for (let vi = 0; vi < numStr; vi++) {
    const si = stringOrder[vi];
    const x = PL + vi * strW;
    if (fretMap[vi] === undefined) {
      svg += `<text x="${x}" y="${PT-9}" text-anchor="middle" font-family="JetBrains Mono" font-size="10" fill="#e74c3c" font-weight="700">Ã—</text>`;
    } else if (fretMap[vi] === 0) {
      const si0 = stringOrder[vi];
      const noteIdx0 = tuningMidi[si0] % 12;
      const iv0 = (noteIdx0 - state.rootNote + 12) % 12;
      const openC = CHORD_INTERVAL_COLORS[iv0] || '#dfe6e9';
      svg += `<circle cx="${x}" cy="${PT-10}" r="4" fill="none" stroke="${openC}" stroke-width="1.5"/>`;
    } else {
      svg += `<text x="${x}" y="${PT-9}" text-anchor="middle" font-family="JetBrains Mono" font-size="9" fill="#555570">${strLabels[si]}</text>`;
    }
  }

  // Fret number label (if not starting at fret 1)
  if (fretWindow > 1) {
    svg += `<text x="${PL-4}" y="${PT + fretH*0.6}" text-anchor="end" font-family="JetBrains Mono" font-size="9" fill="#8888aa">${fretWindow}</text>`;
  }

  // Nut or top line
  const nutH = fretWindow === 1 ? 5 : 2;
  const nutColor = fretWindow === 1 ? '#f0ead6' : '#555570';
  svg += `<rect x="${PL}" y="${PT-nutH}" width="${strW*(numStr-1)}" height="${nutH}" fill="${nutColor}" rx="1"/>`;

  // Fret lines
  for (let f = 0; f <= numFrets; f++) {
    const y = PT + f * fretH;
    svg += `<line x1="${PL}" y1="${y}" x2="${PL+strW*(numStr-1)}" y2="${y}" stroke="#3a3a50" stroke-width="${f===0?0:1}"/>`;
  }
  // String lines
  for (let vi = 0; vi < numStr; vi++) {
    const x = PL + vi * strW;
    svg += `<line x1="${x}" y1="${PT}" x2="${x}" y2="${PT+numFrets*fretH}" stroke="#55556680" stroke-width="1"/>`;
  }

  // Interval colours within the diagram â€” shared with fretboard via CHORD_INTERVAL_COLORS
  const ivColors = { ...CHORD_INTERVAL_COLORS };

  // Note dots
  voicing.forEach(v => {
    if (v.f === 0) return;
    const fw = v.f - fretWindow + 1;
    if (fw < 1 || fw > numFrets) return;
    const x = PL + v.vi * strW;
    const y = PT + (fw - 0.5) * fretH;
    const si = stringOrder[v.vi];
    const noteIdx = (tuningMidi[si] + v.f) % 12;
    const isRoot = (noteIdx % 12) === (state.rootNote % 12);
    const iv = (noteIdx - state.rootNote + 12) % 12;
    const dotColor = ivColors[iv] || '#dfe6e9';
    if (isRoot) {
      const dr = 7;
      svg += `<polygon points="${x},${y-dr} ${x+dr},${y} ${x},${y+dr} ${x-dr},${y}" fill="${dotColor}" stroke="#fff" stroke-width="1"/>`;
    } else {
      svg += `<circle cx="${x}" cy="${y}" r="6.5" fill="${dotColor}" stroke="#ffffff22" stroke-width="1"/>`;
    }
    svg += `<text x="${x}" y="${y+3.5}" text-anchor="middle" font-family="JetBrains Mono" font-size="8" font-weight="700" fill="#000">${NOTES[noteIdx]}</text>`;
  });

  svg += '</svg>';
  return svg;
}

function shiftChordDiagram(cacheKey, dir) {
  const v = state.chordShapeVoicings[cacheKey];
  if (!v) return;
  state.chordShapeIndex[cacheKey] = ((state.chordShapeIndex[cacheKey] || 0) + dir + v.length) % v.length;
  renderChordDiagrams();
  draw(); // sync fretboard to selected voicing
}

function clearChordDiagramCache() {
  state.chordShapeVoicings = {};
  state.chordShapeIndex = {};
  state.scalePositionCache = {};
  state.scalePositionIndex = 0;
}

function shiftScalePosition(dir) {
  if (!state.selectedScales.length) return;
  const cacheKey = state.selectedScales[0] + '_' + state.rootNote + '_' + state.tuning;
  if (!state.scalePositionCache[cacheKey]) return;
  const len = state.scalePositionCache[cacheKey].length;
  state.scalePositionIndex = ((state.scalePositionIndex || 0) + dir + len) % len;
  renderScalePositionNav();
  draw();
}

function renderScalePositionNav() {
  const nav = document.getElementById('scalePositionNav');
  if (!nav) return;
  if (!state.selectedScales.length) { nav.innerHTML = ''; return; }
  const cacheKey = state.selectedScales[0] + '_' + state.rootNote + '_' + state.tuning;
  // Ensure positions are computed
  if (!state.scalePositionCache[cacheKey]) {
    const scale = SCALES[state.selectedScales[0]];
    state.scalePositionCache[cacheKey] = computeScalePositions(scale.intervals, state.rootNote, TUNINGS[state.tuning], state.numFrets);
    state.scalePositionIndex = 0;
  }
  const positions = state.scalePositionCache[cacheKey];
  if (!positions || positions.length <= 1) { nav.innerHTML = ''; return; }
  const idx = Math.max(0, Math.min(state.scalePositionIndex, positions.length - 1));
  const color = SCALE_COLORS[0];
  nav.innerHTML = `<div style="display:flex;align-items:center;gap:6px;margin-top:8px;padding:4px 0;">
    <button onclick="shiftScalePosition(-1)" style="background:#1a1a28;border:1px solid ${color}55;border-radius:4px;color:${color};cursor:pointer;padding:3px 8px;font-size:13px;">&#9664;</button>
    <span style="color:${color};font-size:0.82em;min-width:70px;text-align:center;">Position ${idx+1}/${positions.length}</span>
    <button onclick="shiftScalePosition(1)" style="background:#1a1a28;border:1px solid ${color}55;border-radius:4px;color:${color};cursor:pointer;padding:3px 8px;font-size:13px;">&#9654;</button>
  </div>`;
}

// ===== GUITAR AUDIO ENGINE (Karplus-Strong plucked string + plate reverb) =====
let gfxAudioCtx = null;
let gfxMaster = null;

function getGfxAudio() {
  if (gfxAudioCtx) return gfxAudioCtx;
  gfxAudioCtx = new (window.AudioContext || window.webkitAudioContext)();

  // Dynamics compressor â€” keeps loud chords clean
  const comp = gfxAudioCtx.createDynamicsCompressor();
  comp.threshold.value = -18; comp.knee.value = 10;
  comp.ratio.value = 6; comp.attack.value = 0.003; comp.release.value = 0.15;
  comp.connect(gfxAudioCtx.destination);

  // Synthetic plate reverb via convolver
  const rate = gfxAudioCtx.sampleRate;
  const revLen = Math.floor(rate * 2.0);
  const revBuf = gfxAudioCtx.createBuffer(2, revLen, rate);
  for (let c = 0; c < 2; c++) {
    const d = revBuf.getChannelData(c);
    for (let i = 0; i < revLen; i++)
      d[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / revLen, 2.8) * (c ? -0.9 : 1);
  }
  const conv = gfxAudioCtx.createConvolver();
  conv.buffer = revBuf;
  const revGain = gfxAudioCtx.createGain();
  revGain.gain.value = 0.22;
  conv.connect(revGain); revGain.connect(comp);

  // Master bus: dry + wet
  gfxMaster = gfxAudioCtx.createGain();
  gfxMaster.gain.value = 0.65;
  gfxMaster.connect(comp);
  gfxMaster.connect(conv);

  return gfxAudioCtx;
}

function midiToFreq(midi) { return 440 * Math.pow(2, (midi - 69) / 12); }

function playGuitarNote(freq, when, duration) {
  duration = duration || 2.2;
  const ctx = getGfxAudio();
  const rate = ctx.sampleRate;
  const period = Math.round(rate / freq);
  if (period < 2 || period > 10000) return;

  // ---- Offline Karplus-Strong ----
  // Compute the entire plucked string waveform in JS first,
  // then play it as a plain AudioBuffer â€” zero feedback loops possible.
  const numSamples = Math.floor(rate * duration);
  const pcm = new Float32Array(numSamples);
  const dl  = new Float32Array(period);

  // Seed delay line with smoothed noise (pluck excitation)
  for (let i = 0; i < period; i++) dl[i] = Math.random() * 2 - 1;
  for (let i = 1; i < period; i++) dl[i] = dl[i] * 0.4 + dl[i - 1] * 0.6;

  // Run KS: averaged low-pass feedback (damp controls brightness + sustain)
  const damp = 0.4985;
  let rp = 0;
  for (let i = 0; i < numSamples; i++) {
    const np = (rp + 1) % period;
    pcm[i] = dl[rp];
    dl[rp] = damp * (dl[rp] + dl[np]);
    rp = np;
  }

  // Tiny fade-in to remove click, fade-out at end
  const fadeIn  = Math.min(64, period);
  const fadeOut = Math.floor(rate * 0.04);
  for (let i = 0; i < fadeIn; i++)  pcm[i] *= i / fadeIn;
  for (let i = 0; i < fadeOut; i++) pcm[numSamples - 1 - i] *= i / fadeOut;

  const audioBuf = ctx.createBuffer(1, numSamples, rate);
  audioBuf.getChannelData(0).set(pcm);

  const src = ctx.createBufferSource();
  src.buffer = audioBuf;

  // Body EQ: warmth + high-freq roll-off
  const body = ctx.createBiquadFilter();
  body.type = 'peaking'; body.frequency.value = 220; body.gain.value = 4; body.Q.value = 1.0;
  const shelf = ctx.createBiquadFilter();
  shelf.type = 'highshelf'; shelf.frequency.value = 4000; shelf.gain.value = -5;

  const env = ctx.createGain();
  env.gain.value = 0.7;

  src.connect(body); body.connect(shelf); shelf.connect(env); env.connect(gfxMaster);
  src.start(when);
  src.stop(when + duration);
  src.onended = () => { try { env.disconnect(); } catch(e) {} };
}

// Strum all notes of the current voicing for the first selected chord
function strumCurrentVoicing() {
  const ctx = getGfxAudio();
  if (ctx.state === 'suspended') ctx.resume();
  const tuningMidi = TUNINGS[state.tuning];
  const stringOrder = state.flipV ? [5,4,3,2,1,0] : [0,1,2,3,4,5];
  if (!state.selectedChords.length) return;
  const cacheKey = state.selectedChords[0] + '_' + state.rootNote + '_' + state.tuning;
  const voicings = state.chordShapeVoicings[cacheKey];
  if (!voicings || !voicings.length) return;
  const voicing = voicings[state.chordShapeIndex[cacheKey] || 0];
  const now = ctx.currentTime + 0.05;
  voicing.forEach((v, i) => {
    const midi = tuningMidi[stringOrder[v.vi]] + v.f;
    playGuitarNote(midiToFreq(midi), now + i * 0.045);
  });
}

// Play a single fretboard note (called on canvas click)
function playFretboardNote(vi, f) {
  const ctx = getGfxAudio();
  if (ctx.state === 'suspended') ctx.resume();
  const tuningMidi = TUNINGS[state.tuning];
  const stringOrder = state.flipV ? [5,4,3,2,1,0] : [0,1,2,3,4,5];
  playGuitarNote(midiToFreq(tuningMidi[stringOrder[vi]] + f), ctx.currentTime + 0.02, 2.5);
}

// Note hit areas populated during draw() for click detection
const drawnNoteHits = [];

// ===== TAB PLAYER =====
let tabTimer = null;
let tabAudioCtx = null;

function getTabAudio() {
  if (!tabAudioCtx) tabAudioCtx = new (window.AudioContext || window.webkitAudioContext)();
  return tabAudioCtx;
}

function parseTab(text) {
  const allBeats = [];
  const lines = text.split('\n');
  // prefixOrder = top to bottom in standard ASCII tab notation
  const prefixOrder = ['e', 'B', 'G', 'D', 'A', 'E'];
  // Maps string prefix â†’ MIDI string index (low E=0, A=1, D=2, G=3, B=4, high e=5)
  const prefixToMidi = { 'E': 0, 'A': 1, 'D': 2, 'G': 3, 'B': 4, 'e': 5 };

  let i = 0;
  while (i < lines.length) {
    // Try to match a block of 6 string lines starting near line i
    const blockLines = {};
    let j = i;
    let attempts = 0;
    while (j < lines.length && Object.keys(blockLines).length < 6 && attempts < 20) {
      attempts++;
      const line = lines[j].trim();
      for (const prefix of prefixOrder) {
        const re = new RegExp('^' + (prefix === 'e' ? 'e' : prefix === 'E' ? 'E' : prefix) + '\\s*\\|');
        if (!blockLines[prefix] && re.test(line)) {
          const pipeIdx = line.indexOf('|');
          blockLines[prefix] = line.substring(pipeIdx + 1);
          break;
        }
      }
      j++;
    }

    if (Object.keys(blockLines).length === 6) {
      const strings = prefixOrder.map(p => blockLines[p] || '');
      const maxLen = Math.max(...strings.map(s => s.length));
      let pos = 0;
      while (pos < maxLen) {
        const beatNotes = [];
        let skipExtra = false;
        for (let si = 0; si < 6; si++) {
          const ch = strings[si][pos];
          if (!ch || ch === '-' || ch === '|' || ch === ' ') continue;
          if (ch === 'x' || ch === 'X') {
            beatNotes.push({ string: prefixToMidi[prefixOrder[si]], fret: null });
          } else if (ch >= '0' && ch <= '9') {
            let fretStr = ch;
            const next = strings[si][pos + 1];
            if (next && next >= '0' && next <= '9') { fretStr += next; skipExtra = true; }
            beatNotes.push({ string: prefixToMidi[prefixOrder[si]], fret: parseInt(fretStr) });
          }
        }
        if (beatNotes.length > 0) allBeats.push(beatNotes);
        pos += skipExtra ? 2 : 1;
      }
      i = j;
    } else {
      i++;
    }
  }
  return allBeats;
}

function playTabString(audioCtx, midiNote, time, duration) {
  const freq = 440 * Math.pow(2, (midiNote - 69) / 12);
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  const filter = audioCtx.createBiquadFilter();
  osc.type = 'triangle';
  osc.frequency.value = freq;
  filter.type = 'lowpass';
  filter.frequency.value = Math.min(freq * 4, 8000);
  osc.connect(filter); filter.connect(gain); gain.connect(audioCtx.destination);
  gain.gain.setValueAtTime(0.4, time);
  gain.gain.exponentialRampToValueAtTime(0.001, time + duration);
  osc.start(time); osc.stop(time + duration);
}

function playTabBeat(beat) {
  const actx = getTabAudio();
  if (actx.state === 'suspended') actx.resume();
  const bpm = parseInt(document.getElementById('tabBpm').value) || 120;
  const duration = (60 / bpm) * 0.9;
  const tuningMidi = TUNINGS[state.tuning];
  const now = actx.currentTime;
  beat.forEach(note => {
    if (note.fret === null) return;
    playTabString(actx, tuningMidi[note.string] + note.fret, now, duration);
  });
}

function loadTab() {
  const text = document.getElementById('tabTextarea').value;
  if (!text.trim()) { document.getElementById('tabNoteStatus').textContent = 'Paste a tab first.'; return; }
  state.tabBeats = parseTab(text);
  state.tabCurrentBeat = -1;
  if (state.tabPlaying) tabStop();
  const count = state.tabBeats.length;
  document.getElementById('tabBeatCount').textContent = count > 0 ? count + ' beats' : '0 beats (check format)';
  document.getElementById('tabNoteStatus').textContent = count > 0 ? 'Ready â€” ' + count + ' beats loaded' : 'No beats found â€” use standard ASCII tab format';
  document.getElementById('tabBeatDisplay').textContent = 'Beat \u2014 / ' + count;
  document.getElementById('tabProgFill').style.width = '0%';
  draw();
}

function tabPlayPause() {
  if (!state.tabBeats.length) { document.getElementById('tabNoteStatus').textContent = 'Load a tab first.'; return; }
  if (state.tabPlaying) tabPause(); else tabPlay();
}

function tabPlay() {
  state.tabPlaying = true;
  document.getElementById('tabPlayBtn').textContent = '\u23F8 Pause';
  document.getElementById('tabPlayBtn').classList.add('active');
  tabPlayStep();
}

function tabPause() {
  state.tabPlaying = false;
  clearTimeout(tabTimer); tabTimer = null;
  document.getElementById('tabPlayBtn').textContent = '\u25B6 Play';
  document.getElementById('tabPlayBtn').classList.remove('active');
}

function tabStop() {
  state.tabPlaying = false;
  state.tabCurrentBeat = -1;
  clearTimeout(tabTimer); tabTimer = null;
  const btn = document.getElementById('tabPlayBtn');
  if (btn) { btn.textContent = '\u25B6 Play'; btn.classList.remove('active'); }
  updateTabUI();
  draw();
}

function tabSeekStart() {
  if (state.tabPlaying) tabPause();
  state.tabCurrentBeat = -1;
  updateTabUI();
  draw();
}

function tabToggleLoop() {
  state.tabLoop = !state.tabLoop;
  document.getElementById('tabLoopBtn').classList.toggle('active', state.tabLoop);
}

function tabPlayStep() {
  if (!state.tabPlaying) return;
  state.tabCurrentBeat++;
  if (state.tabCurrentBeat >= state.tabBeats.length) {
    if (state.tabLoop) { state.tabCurrentBeat = 0; }
    else { tabStop(); return; }
  }
  playTabBeat(state.tabBeats[state.tabCurrentBeat]);
  updateTabUI();
  draw();
  const bpm = parseInt(document.getElementById('tabBpm').value) || 120;
  tabTimer = setTimeout(tabPlayStep, 60000 / bpm);
}

function updateTabUI() {
  const total = state.tabBeats.length;
  const cur = state.tabCurrentBeat;
  const fill = document.getElementById('tabProgFill');
  const disp = document.getElementById('tabBeatDisplay');
  const status = document.getElementById('tabNoteStatus');
  if (fill) fill.style.width = (cur < 0 || !total ? 0 : ((cur + 1) / total) * 100) + '%';
  if (disp) disp.textContent = 'Beat ' + (cur < 0 ? '\u2014' : cur + 1) + ' / ' + (total || '\u2014');
  if (status && cur >= 0 && state.tabBeats[cur]) {
    const tuningMidi = TUNINGS[state.tuning];
    const names = state.tabBeats[cur].filter(n => n.fret !== null)
      .map(n => NOTES[(tuningMidi[n.string] + n.fret) % 12]);
    status.textContent = names.length ? 'Notes: ' + names.join(', ') : 'Muted';
  }
}

function init() {
  initMode();
  buildRootNotes();
  buildScaleList();
  buildChordList();
  renderChordDiagrams();
  draw();
}

// Override buildRootNotes to also rebuild chord labels when root changes
buildRootNotes = function() {
  const container = document.getElementById('rootNotes');
  container.innerHTML = '';
  NOTES.forEach((note, i) => {
    const btn = document.createElement('button');
    btn.className = 'note-btn' + (i === state.rootNote ? ' active' : '');
    btn.textContent = note;
    btn.onclick = () => {
      if (cycling) stopCycle();
      state.rootNote = i;
      clearChordDiagramCache();
      buildRootNotes();
      buildChordList();
      renderChordDiagrams();
      draw();
    };
    container.appendChild(btn);
  });
};

// ===== ROOT NOTE CYCLING ANIMATION =====
let cycleTimer = null;
let cycling = false;

const CYCLE_ORDERS = {
  chromatic: [0,1,2,3,4,5,6,7,8,9,10,11],
  fourths:   [0,5,10,3,8,1,6,11,4,9,2,7],  // C F Bb Eb Ab Db Gb B E A D G
  fifths:    [0,7,2,9,4,11,6,1,8,3,10,5],   // C G D A E B F# Db Ab Eb Bb F
};

function toggleCycle() {
  if (cycling) {
    stopCycle();
  } else {
    startCycle();
  }
}

function startCycle() {
  cycling = true;
  state.cycleOriginRoot = state.rootNote; // remember starting root for scale-note mode
  const btn = document.getElementById('cycleBtn');
  btn.textContent = '\u23F8 Pause';
  btn.classList.add('active');
  const speed = parseInt(document.getElementById('cycleSpeed').value);
  cycleStep();
  cycleTimer = setInterval(cycleStep, speed);
}

function stopCycle() {
  cycling = false;
  clearInterval(cycleTimer);
  cycleTimer = null;
  const btn = document.getElementById('cycleBtn');
  btn.textContent = '\u25B6 Play';
  btn.classList.remove('active');
}

function getScaleNoteOrder() {
  // Build order from the first selected scale's notes, sorted by pitch
  if (state.selectedScales.length === 0) return CYCLE_ORDERS.chromatic;
  const scale = SCALES[state.selectedScales[0]];
  // Get absolute note indices for the scale starting from current root context
  // We use the root that was active when cycling started, cycling through scale degrees
  return scale.intervals.map(iv => (state.cycleOriginRoot + iv) % 12);
}

function cycleStep() {
  const mode = document.getElementById('cycleMode').value;
  let order;
  if (mode === 'scaleNotes') {
    order = getScaleNoteOrder();
    if (order.length === 0) { stopCycle(); return; }
  } else {
    order = CYCLE_ORDERS[mode];
  }
  const currentIdx = order.indexOf(state.rootNote);
  // If current root isn't in the order (e.g. switched scale), start from beginning
  const nextIdx = currentIdx === -1 ? 0 : (currentIdx + 1) % order.length;
  state.rootNote = order[nextIdx];
  buildRootNotes();
  buildChordList();
  draw();
}

function updateCycleSpeed() {
  if (cycling) {
    clearInterval(cycleTimer);
    const speed = parseInt(document.getElementById('cycleSpeed').value);
    cycleTimer = setInterval(cycleStep, speed);
  }
}

// ===== KEYBOARD NAVIGATION =====
document.addEventListener('keydown', (e) => {
  // ESC stops tab playback
  if (e.key === 'Escape' && state.tabPlaying) {
    e.preventDefault(); tabStop(); return;
  }
  if (state.highlightGroups.length === 0) return;
  const total = state.cachedVoicings ? state.cachedVoicings.length : 0;
  if (total === 0) return;

  if (e.key === 'ArrowRight' || e.key === 'ArrowDown') {
    e.preventDefault();
    state.voicingIndex = (state.voicingIndex + 1) % total;
    draw();
  } else if (e.key === 'ArrowLeft' || e.key === 'ArrowUp') {
    e.preventDefault();
    state.voicingIndex = (state.voicingIndex - 1 + total) % total;
    draw();
  } else if (e.key === 'Escape') {
    e.preventDefault();
    state.highlightGroups = [];
    state._voicingCacheKey = null;
    draw();
  } else if (e.key === 'Home') {
    e.preventDefault();
    state.voicingIndex = 0;
    draw();
  } else if (e.key === 'End') {
    e.preventDefault();
    state.voicingIndex = total - 1;
    draw();
  }
});

window.addEventListener('resize', () => draw());
window.addEventListener('DOMContentLoaded', init);

// roundRect polyfill
if (!CanvasRenderingContext2D.prototype.roundRect) {
  CanvasRenderingContext2D.prototype.roundRect = function(x, y, w, h, r) {
    if (typeof r === 'number') r = [r,r,r,r];
    this.moveTo(x+r[0], y);
    this.lineTo(x+w-r[1], y);
    this.quadraticCurveTo(x+w, y, x+w, y+r[1]);
    this.lineTo(x+w, y+h-r[2]);
    this.quadraticCurveTo(x+w, y+h, x+w-r[2], y+h);
    this.lineTo(x+r[3], y+h);
    this.quadraticCurveTo(x, y+h, x, y+h-r[3]);
    this.lineTo(x, y+r[0]);
    this.quadraticCurveTo(x, y, x+r[0], y);
    this.closePath();
  };
}
</script>
</body>
</html>
